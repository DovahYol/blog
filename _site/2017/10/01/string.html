<!DOCTYPE html>
<html>
<head>
　　<meta http-equiv="content-type" content="text/html; charset=utf-8" />
　　　　<title>String</title>
<script src="http://127.0.0.1:35729/livereload.js"></script></head>
<body>
　　<p>//TODO<br />
substring search（子字符串查找）<br />
formal languages（形式语言）<br />
finite automata（有限自动机）<br />
data compression（数据压缩）</p>

<p>Java的char是两个byte，因为他是unicode</p>
<h1 id="51-字符串排序-string-sorts">5.1 字符串排序 String sorts</h1>

<ul>
  <li>低位优先 least-significant-digit LSD</li>
  <li>高位优先 most-significant-digit MSD</li>
</ul>

<h2 id="键索引计数法-key-indexed-counting">键索引计数法 key-indexed counting</h2>

<p>一种稳定的排序法</p>

<ol>
  <li>频率统计</li>
  <li>将频率转化为索引</li>
  <li>数据分类</li>
  <li>回写</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

<span class="n">String</span><span class="o">[]</span> <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

<span class="c1">//计算出现频率</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">key</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]++;</span>
<span class="c1">//将频率转换为索引</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span>
    <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
<span class="c1">//将元素分类</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">aux</span><span class="o">[</span><span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">key</span><span class="o">()]++]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
<span class="c1">//回写</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</code></pre></div></div>

<h2 id="低位优先的字符串排序-lsd-string-sort">低位优先的字符串排序 LSD string sort</h2>

<p>用键索引计数法将定长字符串组<code class="highlighter-rouge">从右至左</code>排序w次</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LSD</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">W</span><span class="o">){</span>
        <span class="c1">//通过前W个字符将a[]排序</span>
        <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">256</span><span class="o">;</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">W</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">d</span><span class="o">--){</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
                <span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]++;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span>
                <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
                <span class="n">aux</span><span class="o">[</span><span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">)]++]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span>
                <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="高位优先的字符串排序-msd-string-sort">高位优先的字符串排序 MSD string sort</h2>

<p>在将一个字符串数组a[]排序时，首先根据它们的首字母用键索引计数法进行排序，然后（递归地）根据子数组中的字符串的首字母将子数组排序</p>

<p><a href="http://algs4.cs.princeton.edu/51radix/">课程链接</a></p>

<h2 id="三向字符串快速排序-three-way-string-quicksort">三向字符串快速排序 Three-way string quicksort</h2>

<p>在将字符串数组a[]排序时，根据它们的首字母进行三向切分，然后（递归地）将得到的三个子数组排序：一个含有所有首字母小于切分字符的字符串子数组，一个含有所有首字母等于切分字符的字符串的子数组（排序时忽略它们的首字母），一个含有所有首字母大于切分字符的字符串的子数组</p>

<h1 id="52-字典树-tries">5.2 字典树 TRIES</h1>

<p><code class="highlighter-rouge">每个节点都含有R条链接，其中R为字母表的大小</code></p>

<p>字典树一般都含有大量的空链接，因此在绘制一棵字典树时一般会忽略空链接</p>

<p>每个节点都对应一个值，可以是空的也可以是符号表中的某个键所关联的值</p>

<p><code class="highlighter-rouge">查找</code></p>
<ol>
  <li>尾字符节点的值非空，命中</li>
  <li>尾字符节点的值为空，未命中</li>
  <li>查找的过程中有空链接，未命中</li>
</ol>

<p><code class="highlighter-rouge">插入</code></p>
<ol>
  <li>存在尾字符节点，更新</li>
  <li>查找过程中有空链接，建立所有不存在的节点，并将值保存在尾节点</li>
</ol>

<p>查找所有键 collect()</p>
<ul>
  <li>DFS遍历所有节点，并将所有字符串加入集合</li>
</ul>

<p>通配符匹配 wildcard match</p>
<ul>
  <li>改造collect()</li>
</ul>

<p>最长前缀</p>
<ul>
  <li>记录查找路径上最长键的长度</li>
  <li>遇到空链接或被查找字符串结束时终止</li>
</ul>

<p><code class="highlighter-rouge">删除</code></p>
<ul>
  <li>在递归删除了某个节点x之后，如果该节点的值和所有的链接均为空则返回null，否则返回x</li>
</ul>

<h3 id="性质">性质</h3>

<p>字典树的形状与键的插入或删除无关：对于任意给定的一组键，其字典树都是唯一的</p>

<p>查找未命中的成本与键的长度无关</p>

<ul>
  <li>一棵字典树的链接总数在RN和RNw之间，其中w为键的平均长度</li>
  <li>不要用其处理来自大型字母表的大量长键，空间消耗太大</li>
</ul>

<h2 id="三向单词查找树-ternary-search-trieststs">三向单词查找树 Ternary search tries（TSTs）</h2>

<p><code class="highlighter-rouge">每个节点都含有一个字符、三条链接和一个值</code></p>

<p>三条链接，从左至右依次变大</p>

<p>查找</p>
<ul>
  <li>如果键小于中儿子，则查找左儿子；若大于中儿子，则查找右儿子；若等于中儿子，则迭代下一字符</li>
</ul>

<p>插入</p>
<ol>
  <li>存在尾字符节点，更新</li>
  <li>查找过程中有空链接，建立所有不存在的节点，并将值保存在尾节点</li>
</ol>

<h3 id="性质-1">性质</h3>

<p>由N个平局长度为w的字符串构造的三向单词查找树中的链接总数在3N和3Nw之间</p>

<h1 id="53-子字符串查找-substring-search">5.3 子字符串查找 SUBSTRING SEARCH</h1>

<p>给定一段长度为N的文本和一个长度为M的模式字符串，在文本中找到一个和该模式相符的子字符串</p>

<h2 id="暴力字符串查找算法-brute-force-substring-search">暴力字符串查找算法 Brute-force substring search</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">pat</span><span class="o">,</span> <span class="n">String</span> <span class="n">txt</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="kt">int</span> <span class="n">j</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
            <span class="k">if</span><span class="o">(</span><span class="n">txt</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">)</span> <span class="o">!=</span> <span class="n">pat</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span>
                <span class="k">break</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">M</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>KMP算法 Knuth-Morris-Pratt substring search</p>

<p>//TODO 很难理解</p>

<p>Boyer-Moore substring search</p>


</body>
</html>