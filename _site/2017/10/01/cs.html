<!DOCTYPE html>
<html>
<head>
　　<meta http-equiv="content-type" content="text/html; charset=utf-8" />
　　　　<title>Cs</title>
<script src="http://127.0.0.1:35729/livereload.js"></script></head>
<body>
　　<p>MOS（金属氧化物半导体 Metal-Oxide-Semiconductor）</p>

<p>N型MOS管</p>
<ul>
  <li>Gate端连接了高电平，晶体管导通，电流从源（Source）流到漏（Drain）</li>
</ul>

<p>P型MOS管</p>
<ul>
  <li>Gate端连接了低电平，晶体管导通，电流从源（Source）流到漏（Drain）</li>
</ul>

<h1 id="第三讲-算术逻辑单元">第三讲 算术逻辑单元</h1>
<p><img src="imgs/MOS.png" alt="MOS" /></p>

<p>非门
<img src="imgs/notgate.png" alt="非门" /></p>

<p>与门
<img src="imgs/andgate.png" alt="与门" /></p>

<p>或门
<img src="imgs/orgate.png" alt="或门" /></p>

<p>异或门
<img src="imgs/xorgate.png" alt="异或门" /></p>

<p>寄存器由32个D触发器构成</p>
<blockquote>
  <p>D触发器
<img src="imgs/Dflipflop.png" alt="D触发器" />
原理
<img src="imgs/d2.png" alt="原理" />
逻辑运算的实现
<img src="imgs/logicala.png" alt="逻辑运算" /></p>
</blockquote>

<h2 id="加减法的实现">加减法的实现</h2>

<p>半加器
<img src="imgs/halfadd.png" alt="半加器" /></p>

<p>全加器<br />
<img src="imgs/fulladd.png" alt="全加器" /></p>

<p>加法的实现(行波进位加法器)
<img src="imgs/addimpl.png" alt="加法的实现" /></p>

<p>溢出的检查方法</p>
<blockquote>
  <p>“最高位的进位输入“不等于”最高位的进位输出“<br />
<img src="imgs/overflow.png" alt="溢出的检查方法" /></p>
</blockquote>

<p>减法的实现<br />
<img src="imgs/subimpl.png" alt="减法的实现" /></p>

<p>行波进位加法器
<img src="imgs/RCA.png" alt="行波进位加法器" />
关键路径<br />
<img src="imgs/rca-lag.png" alt="关键路径" /></p>

<p>进位输出信号的分析
<img src="imgs/carry1.png" alt="进位输出信号" />
<img src="imgs/carry2.png" alt="进位输出信号" />
<img src="imgs/cla1.png" alt="超前进位加法器" />
<img src="imgs/cla2.png" alt="超前进位加法器" /></p>

<p>4级CLA的延迟时间为13T<br />
<img src="imgs/cla3.png" alt="超前进位加法器" /></p>

<h1 id="第四讲-乘法器和除法器-todo">第四讲 乘法器和除法器 //TODO</h1>

<h1 id="第五讲-单周期处理器-todo">第五讲 单周期处理器 //TODO</h1>
<p>处理器设计的五个步骤</p>
<ol>
  <li>分析指令系统，得出对数据通路的需求</li>
  <li>为数据通路选择合适的组件</li>
  <li>连接组件建立数据通路</li>
  <li>分析每条指令的实现，已确定控制信号</li>
  <li>集成控制信号，形成完整的控制逻辑</li>
</ol>

<p>控制信号的集成//TODO</p>

<h1 id="第六讲-流水线处理器">第六讲 流水线处理器</h1>

<p>流水线，超标量；双发射，5级流水线</p>

<h2 id="结构冒险">结构冒险</h2>

<p>主存遵从冯诺依曼结构，同时存放数据和指令；一级缓存分别存放数据和指令，即IMem和DMem，这样就不会产生结构冒险的问题。</p>

<p>对于寄存器堆来说，他也会产生结构冒险的问题，比如同时执行指令译码阶段（ID)的读和写回阶段（WB）写，而这可以利用寄存器的特性来避免。</p>

<p>因为寄存器的周期比其他部件小，设为二分之一，那么只要使其在前二分之一的周期写，后二分之一的周期读，并设置独立的读写接口。</p>

<h2 id="数据冒险">数据冒险</h2>

<p>举例：</p>
<pre><code class="language-mipsasm">sub $t0,$s1,$s2
add $s3,$t0,$s4
</code></pre>

<p>add指令需要sub的完成以利用$t0</p>

<p><img src="imgs/h1.png" alt="数据冒险" />
<img src="imgs/h4.png" alt="数据冒险" />
<img src="imgs/h5.png" alt="数据冒险" />
<img src="imgs/h6.png" alt="数据冒险" /></p>

<p>Load-Use Hazard</p>

<p>我们可以：</p>
<ol>
  <li>让流水线停顿（stall），产生空泡（bubble）
    <ul>
      <li>即一条指令需要使用之前指令的运算结果，但是结果还没有写回</li>
    </ul>
  </li>
  <li>插入nop指令（软件层面解决问题）
    <ul>
      <li>缺点：与处理器结构相关，当前处理器的流水线是5级的，新处理器的流水线是8级的，这一调换就会产生错误。</li>
    </ul>
  </li>
  <li>数据前递（Forwarding），又称旁路（Bypass），寄存器直通（register forwarding），转发机制</li>
</ol>

<h2 id="控制冒险">控制冒险</h2>

<p>在branch指令的第二条指令的取指阶段，由于并不知道上一条指令结束后是否发生分支（ALU产生的zero信号），就无法确定取指的地址，这就造成了控制冒险。</p>

<p><img src="imgs/h3.png" alt="控制冒险" />
<img src="imgs/h7.png" alt="控制冒险" />
<img src="imgs/h8.png" alt="控制冒险" /></p>

<p>直接转移</p>
<ul>
  <li>j Target
    <ul>
      <li>J型指令，前6位opcode,后26位address</li>
      <li>New PC = {(PC + 4)[31..28], address, 00}</li>
      <li>所需信息在取指阶段即可获得，流水线不停顿</li>
    </ul>
  </li>
  <li>beq rs, rt, imm16
    <ul>
      <li>I型指令，前6位opcode，5位rs，5位rt，16位立即数
        <div class="language-vb highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">if</span><span class="p">(</span><span class="n">R</span><span class="err">[</span><span class="n">rs</span><span class="err">]</span><span class="o">-</span><span class="n">R</span><span class="err">[</span><span class="n">rt</span><span class="err">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">then</span> <span class="k">New</span> <span class="n">PC</span> <span class="o">=</span> <span class="n">PC</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">SignExt</span><span class="err">[</span><span class="n">imm16</span><span class="err">]</span> <span class="o">*</span> <span class="mi">4</span><span class="err">;</span>
  <span class="n">else</span> <span class="k">New</span> <span class="n">PC</span> <span class="o">=</span> <span class="n">PC</span> <span class="o">+</span> <span class="mi">4</span><span class="err">;</span>
</code></pre></div>        </div>
      </li>
      <li>执行阶段才能完成转移条件的判定（流水线停顿2周期）
        <ul>
          <li>为了判断rs和rt是否相等而使用了ALU</li>
        </ul>
      </li>
      <li>在寄存器堆的输出端增加额外的比较电路（流水线停顿1周期）
        <ul>
          <li>由于判断寄存器相等比较简单，执行速度也非常快，所以可以做以上的硬件改动</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>间接转移</p>
<ul>
  <li>jr rs
    <ul>
      <li>R型指令，前6位opcode,5位rs，5位rt，5位rd，5位shamt，6位funct</li>
      <li>New PC = R[rs]</li>
      <li>译码阶段才能获得转移目标地址（流水线停顿1周期）</li>
    </ul>
  </li>
</ul>

<p>总结以上控制冒险的影响</p>
<ul>
  <li>无条件直接转移： j Target
    <ul>
      <li>流水线无停顿</li>
    </ul>
  </li>
  <li>无条件间接转移： jr rs
    <ul>
      <li>流水线停顿1个周期</li>
    </ul>
  </li>
  <li>条件转移： beq rs,rt,imm16
    <ul>
      <li>流水线停顿1个周期</li>
    </ul>
  </li>
</ul>

<p>延迟转移技术</p>
<ul>
  <li>选择一条与条件转移指令无关的指令放到其后面，这样流水线就不用停顿，也不用废弃相关指令</li>
</ul>

<p>我们可以：</p>
<ol>
  <li>让流水线停顿（stall），产生空泡（bubble）
    <ul>
      <li>这次我们产生两个空泡，等到ALU产生zero信号</li>
    </ul>
  </li>
</ol>

<h1 id="第七讲-存储层次结构todo">第七讲 存储层次结构//TODO</h1>
<p>存储器的特性</p>
<ul>
  <li>非易失性
    <ul>
      <li>易失性存储器：CPU（通用寄存器），主存</li>
      <li>非易失性存储器：硬盘，BIOS芯片</li>
    </ul>
  </li>
  <li>可读可写
    <ul>
      <li>可读可写 主存和硬盘</li>
      <li>只读 BIOS</li>
    </ul>
  </li>
  <li>随机访问
    <ul>
      <li>随机访问 主存和BIOS</li>
      <li>不支持 硬盘</li>
    </ul>
  </li>
  <li>访问时间</li>
  <li>容量</li>
  <li>价格</li>
  <li>功耗</li>
</ul>

<p>计算机启动顺序：CPU-&gt;BISO-&gt;硬盘-&gt;内存</p>

<p>内存交互：CPU &lt;-&gt; Cache(SRAM) &lt;-&gt; Memory(DRAM)</p>

<p>DRAM和SRAM的比较
| | DRAM | SRAM |
| — | — | — |
| 存储单元 | 电容 | 双稳态触发器 |
| 集成度 | <code class="highlighter-rouge">高</code> | 低 |
| 功耗 | <code class="highlighter-rouge">低</code> | 高 |
| 价格 | <code class="highlighter-rouge">低</code> | 高 |
| 速度 | 慢 | <code class="highlighter-rouge">快</code> |
| 刷新 | 有 | <code class="highlighter-rouge">无</code> |</p>

<h2 id="主存的工作原理">主存的工作原理</h2>
<p>DRAM芯片已一个存储阵列（Memory）为核心，这个阵列以行列的形式组织，行列的焦点就是一个存储单元，每个存储单元由一组唯一的行列地址指定，而储存单元通常由若干个比特构成，常见的有4bit和8bit。</p>

<p>内存条通常由8个内存芯片焊接在一块电路板上构成一个内存模组（Memory Module），因此从外部给出了行地址和列地址之后，这些地址会同时送到每一个DRAM芯片，从而在每个内存芯片中选中对应的存储单元， 假如存储单元内含8bit，那可以同时向外传送64个bit</p>

<ol>
  <li>BUS REQUEST
    <ul>
      <li>当CPU需要访问存储器时，首先申请系统总线</li>
      <li>地址发往内存控制器</li>
    </ul>
  </li>
  <li>[Precharge] and Row Access
    <ul>
      <li>内存控制器将地址分为行地址和列地址等多个部分，然后进行访存操作</li>
      <li>预充电和行访问</li>
      <li>通过存储总线发出的行地址会被行译码器（Row Decoder）所接收到，就会在存储阵列中选中对应的那一行，然后这一行所有的存储单元都会被放大（Sense Amplifiers）后放到缓冲区中。而这被称为激活（ACT(Activate)）或者行访问（RAS(Row Access Strobe)）</li>
    </ul>
  </li>
  <li>Column Access
    <ul>
      <li>通过存储总线发出的列地址会被列译码器（Column Decoder）所接收到</li>
      <li>从缓冲区中选出对应的那个数，被选中的数就会送到IO接口上去。而这被称为READ或者列访问（CAS(Column Access Strobe)）</li>
      <li>一般一次读一行</li>
    </ul>
  </li>
  <li>Bus Transmission
    <ul>
      <li>内存控制器采样对应的数据,再送到CPU中去</li>
      <li>若下次访问的是同一行，则直接列访问从缓冲区中取数据就可以</li>
      <li>若不是这一行，就需要把激活的这一行关闭，这个过程称为预充电（Precharge，PRECH）</li>
      <li>预充电可以有两种方式
        <ul>
          <li>再次访问时发现不在同一行，预充电</li>
          <li>每次传出数据时都预充电</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p>tRCD:Row to Column Delay</p>
<ul>
  <li>从行选到列选的延迟时间</li>
  <li>2-3个周期</li>
</ul>

<p>CL:CAS Latency</p>
<ul>
  <li>从列选到数据输出的延迟周期</li>
  <li>2-3个周期</li>
</ul>

<p>tRP:RAS Precharge</p>
<ul>
  <li>行预充电（关闭行）</li>
  <li>2-3个周期</li>
</ul>

<p><code class="highlighter-rouge">为什么在最后一个数据送出之前发出预充电的命令？</code></p>

<p><img src="imgs/h9.png" alt="SDRAM" />
<img src="imgs/h10.png" alt="SDRAM" />
<img src="imgs/h13.png" alt="SDRAM" /></p>

<h2 id="主存技术的发展">主存技术的发展</h2>
<p>内存的传输带宽</p>
<blockquote>
  <ul>
    <li>DDR3-1600</li>
    <li>传输带宽12.8G/Hz</li>
    <li>1600MHz * 64bit/8</li>
  </ul>
</blockquote>

<p>SDR（单倍数据率）</p>
<ul>
  <li>每次访问存储阵列取出单倍的数据量</li>
  <li>每个时钟的上升沿传输数据，接收端也用时钟的上升沿采样数据</li>
</ul>

<p>DDR（双倍数据率）</p>
<ul>
  <li>每次访问存储阵列取出两倍的数据量</li>
  <li>在时钟的上升沿和下降沿都传输数据</li>
  <li>这只是一种传输方式，应用到内存上就是DDR SDRAM，也可以用到其他领域</li>
</ul>

<p><code class="highlighter-rouge">核心频率和等效频率之间的关系</code>
<code class="highlighter-rouge">访存延迟和访存带宽</code></p>

<p>DDR2（四倍数据率）</p>
<ul>
  <li>每次访问存储阵列取出四倍的数据量</li>
  <li>在时钟的上升沿和下降沿都传I/O</li>
  <li>I/O频率为两倍</li>
</ul>

<p>DDR3（八倍数据率）</p>
<ul>
  <li>每次访问存储阵列取出八倍的数据量</li>
  <li>在时钟的上升沿和下降沿都传输数据</li>
  <li>I/O频率为四倍</li>
</ul>

<p>通过DDR技术，带宽得到了大幅提升，而延迟的进步却很有限</p>
<ul>
  <li>1999年到2008年，行选时间（tRCD）延迟只降低了30%</li>
  <li>而列选时间（CL）延迟也只降低了30%</li>
  <li>存储器性能（DRAM）性能增长不到10倍</li>
</ul>

<p>这是由SDRAM的基本单元结构决定的，也就是电容的充放电过程，如果不做材料的优化和改变，基于现在的SDRAM结构，想要优化和提升是很困难的</p>

<h2 id="高速缓存的工作原理">高速缓存的工作原理</h2>
<ol>
  <li>计算机程序从时间和空间都表现出“局部性”</li>
  <li>时间局部性（Temporal Locality)
    <ul>
      <li>最近被访问的存储器单元很快还会被访问</li>
    </ul>
  </li>
  <li>空间局部性（Spatial Locality）
    <ul>
      <li>正在被访问的存储器单元附近的单元很快会被访问</li>
    </ul>
  </li>
</ol>

<p>Cache对空间局部性的利用</p>
<ul>
  <li>从主存中取回待访问数据时，会同时取回与位置相邻的主存单元的数据</li>
  <li>以数据块（Block）为单位和主存进行数据交换</li>
</ul>

<p>Cache对时间局部性的利用</p>
<ul>
  <li>保存近期频繁被访问的主存单元的数据</li>
</ul>

<p>经典例题</p>
<ul>
  <li><code class="highlighter-rouge">循环通常具有很好的时间局部性</code></li>
  <li><code class="highlighter-rouge">循环通常具有很好的空间局部性</code></li>
  <li><code class="highlighter-rouge">数组通常具有很好的空间局部性</code></li>
</ul>

<p>Cache的访问过程：Cache命中（Cache Hit），Cache失效（Cache Miss）</p>

<p><img src="imgs/h11.png" alt="SDRAM" /></p>

<p><code class="highlighter-rouge">Cache取数据块时读内存的地址是16字节对齐</code></p>

<p><img src="imgs/h12.png" alt="Cache" /></p>

<p>Cache的写策略：</p>
<ul>
  <li>“Cache命中”时的写策略
    <ol>
      <li>写穿透（Write Through）：数据同时写入Cache和主存</li>
      <li>写返回（Write Back）：数据只写入Cache，仅当该数据块被替换时才将数据写回主存</li>
    </ol>
  </li>
  <li>“Cache失效”时的写策略
    <ol>
      <li>写不分配（Write Non-Allocate）：直接将数据写入主存</li>
      <li>写分配（Write Allocate）：将该数据所在的块读入Cache后，再将数据写入Cache</li>
    </ol>
  </li>
</ul>

<h2 id="高速缓存的设计要点">高速缓存的设计要点</h2>
<p>命中率（Hit Rate）和失效率（Miss Rate）</p>

<p>命中时间（Hit Time）</p>
<ul>
  <li>从Cache将命中数据返回的时间</li>
  <li>L1 Cache约1-3个周期</li>
  <li>L2 Cache约5-20个周期</li>
</ul>

<p>失效代价（Miss Penalty）</p>
<ul>
  <li>从主存读取数据并返回的时间</li>
  <li>约100-300个周期</li>
</ul>

<p>平均访存时间Average Memory Access Time = Hit Time + Miss Penalty * Miss Rate</p>

<p>Cache失效的原因</p>
<ol>
  <li>义务失效（Compulsory Miss） 第一次访问数据块时，也称冷启失效（Cold Start Miss）</li>
  <li>容量失效（Capacity Miss） Cache无法保存程序访问时所需的所有数据块</li>
  <li>冲突失效（Conflict Miss） 多个存储器位置映射到同一Cache位置</li>
</ol>

<p>Cache的映射策略</p>
<blockquote>
  <p>解决冲突失效</p>
  <ul>
    <li>直接映射Cache</li>
    <li><code class="highlighter-rouge">二路组相连Cache</code></li>
    <li><code class="highlighter-rouge">四路组相连Cache</code></li>
  </ul>
</blockquote>

<p>常见的Cache替换算法</p>
<ul>
  <li>随机（Random)
    <ul>
      <li>硬件随机选择一个Cache块替换</li>
    </ul>
  </li>
  <li>轮换（Round-Robin）
    <ul>
      <li>按照预先设定的顺序依次选择Cache块替换</li>
    </ul>
  </li>
  <li>最近最少使用（LRU）
    <ul>
      <li>硬件记录访问历史信息</li>
      <li>选择距离现在最长时间未被访问的Cache块替换</li>
    </ul>
  </li>
</ul>

<p><code class="highlighter-rouge">分为数据和指令Cache的原因在于解决这两者局部性冲突</code></p>

<h3 id="存储容量的计算">存储容量的计算</h3>
<p>K:2^10, M:2^20, G:2^30, T:2^40</p>

<p>MB和MiB</p>

<h1 id="第八讲-中断和异常todo">第八讲 中断和异常//TODO</h1>

<p>第一个带有异常处理的系统：UNIVAC，1951年</p>
<ul>
  <li>算术运算溢出时：转向地址0执行<code class="highlighter-rouge">两条修复指令</code>，或者停机</li>
</ul>

<p>第一个带有外部中断的系统：DYSEAC，1954年</p>
<ul>
  <li>有两个程序计数器（PC），根据I/O信号进行切换</li>
</ul>

<ol>
  <li>在程序运行时，系统外部、内部或现行程序本身出现需要特殊处理的“事件”</li>
  <li>CPU立即强行中止现行程序的运行，改变机器的工作状态并启动相应的程序来处理这些“事件”</li>
  <li>处理完成后，CPU恢复原来的程序运行</li>
</ol>

<p>8086的主要特点：</p>
<ol>
  <li>对外有16根数据线
    <ul>
      <li>内部有四个16位通用寄存器，既能处理16位数据，也能处理8位数据</li>
    </ul>
  </li>
  <li>对外有20根地址线，可寻址的内存空间为1MB</li>
  <li>物理地址的形成采用“段加偏移”的方式</li>
  <li>存储器中保留两个专用区域
    <ul>
      <li>中断向量表区：00000H~003FFH（地址最低的1KB）
        <ul>
          <li>存放256个中断向量(中断服务程序的入口地址)，每个占4个字节单元</li>
          <li>每个中断类型对应一个中断向量（4字节）</li>
          <li>前两个字节存放入口地址的<code class="highlighter-rouge">偏移量（IP）</code>，后两个字节存放入口地址的<code class="highlighter-rouge">段基值（CS）</code></li>
          <li>CS左移4位 + IP = 物理地址</li>
          <li>CS和IP类似于PC寄存器</li>
        </ul>
      </li>
      <li>初始化程序区：FFFF0H~FFFFFH（地址最高的16B）
 <img src="imgs/h14.png" alt="存储器" /></li>
    </ul>
  </li>
</ol>

<p>指令的寻址</p>
<ul>
  <li>实模式 CS:IP</li>
  <li>保护模式 CS:EIP
    <ul>
      <li>保护模式下，段基址不在CS中，而是在内存中
  <img src="imgs/h15.png" alt="存储器" />
  <img src="imgs/h16.png" alt="存储器" /></li>
    </ul>
  </li>
</ul>

<h2 id="中断的处理过程">中断的处理过程</h2>
<ol>
  <li>关中断
    <ul>
      <li>CPU关闭中断响应，即不再接收其他外部中断请求</li>
    </ul>
  </li>
  <li>保存断点
    <ul>
      <li>将发生中断处的指令地址压入堆栈，以使中断处理完后能正确地返回</li>
    </ul>
  </li>
  <li>识别中断源
    <ul>
      <li>CPU识别中断的来源，确定中断类型型号，从而找到相应的中断服务程序的入口地址</li>
    </ul>
  </li>
  <li>保护现场
    <ul>
      <li>将发生中断处的有关寄存器（中断服务程序中要使用的寄存器）以及标志寄存器的内容压入堆栈</li>
    </ul>
  </li>
  <li>执行中断的服务程序
    <ul>
      <li>转到中断服务程序入口开始执行，可在适当时刻重新开放中断，以便允许响应较高优先级的外部中断
        <ul>
          <li>设置标志寄存器（FLAGS）中的中断标志IF，1为允许CPU响应<code class="highlighter-rouge">可屏蔽中断请求</code>，0为不允许
            <ul>
              <li>STI设置IF为1</li>
              <li>CLI设置IF为0</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>恢复现场，返回主程序继续运行
    <ul>
      <li>把”保护现场“时压入堆栈的信息弹回原寄存器，然后执行中断返回指令，从而返回主程序继续运行
        <ul>
          <li>IRET指令（中断返回）</li>
          <li>从栈顶弹出3个字分别放入IP、CS和FLAGS寄存器</li>
          <li>扩展：IRETD指令，IRETQ指令</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p><img src="imgs/h17.png" alt="存储器" /></p>

<h2 id="内部中断的分类说明">内部中断的分类说明</h2>

<p><code class="highlighter-rouge">除法错中断</code>也被称为<code class="highlighter-rouge">除0中断</code>（类型0）</p>
<ul>
  <li>在执行除法指令后，若所得的商超出了目标寄存器所能表示的范围，比如用数值0作除数，则CPU立即产生一个类型0中断</li>
</ul>

<p><code class="highlighter-rouge">溢出中断</code>（类型4）</p>
<ul>
  <li>执行INTO指令时，若溢出标志为OF为1，则将引起类型为4的内部中断</li>
  <li>执行INTO指令时，若溢出标志为OF为0，则INTO指令执行空操作</li>
  <li>INTO指令通常安排在算术运算指令之后，以便在发生溢出时能及时处理</li>
  <li>INTO指令等同于指令INT 4</li>
</ul>

<pre><code class="language-x86asm">ADD AX, BX
INTO
</code></pre>
<p><code class="highlighter-rouge">单步中断</code>（类型1）</p>
<ul>
  <li>当标志寄存器的TF（跟踪标志）置为1之后，CPU便处于单步工作方式</li>
  <li>在单步工作方式下，CPU每执行完一条指令，就会自动产生一个类型1中断，进入类型1中断服务程序</li>
</ul>

<p><code class="highlighter-rouge">断点中断</code>（类型3）</p>
<ul>
  <li>在所有INT n形式的指令中，只有断点中断指令INT 3是一条单字节长的指令，其他都是两字节指令</li>
  <li>因为在实际调试中，INT 3指令会代替要调试的指令，一个指令的最小长度为一个字节，而为了避免代替过之后剩余的指令产生偏移，必须设置成最小长度。</li>
</ul>

<h3 id="内部中断的特点">内部中断的特点</h3>

<ul>
  <li>中断类型号
    <ul>
      <li>内部中断的类型号由CPU内部产生</li>
      <li>外部中断则需要从外设读取中断类型号</li>
    </ul>
  </li>
  <li>屏蔽方式
    <ul>
      <li>除单步中断外，所有内部中断都不可以用软件方法来禁止（屏蔽）</li>
      <li>单步中断可通过软件将TF标志置1或清0来允许或禁止</li>
    </ul>
  </li>
  <li>优先级
    <ul>
      <li>除单步中断外，所有内部中断的优先级都比外部中断高</li>
    </ul>
  </li>
</ul>

<h2 id="基于中断的功能调用">基于中断的功能调用</h2>

<p>INT n指令说明</p>
<ul>
  <li>x86系统提供的直接调用中断服务程序的手段</li>
  <li>n为0~255中的某一个数，对应中断类型码</li>
  <li>操作
    <ol>
      <li>将FLAGS寄存器的内容压栈</li>
      <li>清除中断标志IF和单步标志TF</li>
      <li>将CS和IF寄存器的内容压栈</li>
      <li>根据中断类型码查找中断向量表，取得对应中断服务程序的入口地址</li>
      <li>将入口地址分别装入CS和IP寄存器</li>
    </ol>
  </li>
</ul>

<ol>
  <li>溢出中断</li>
  <li>BIOS中断
    <pre><code class="language-x86asm"> MOV AH,1    ;设置功能号，对于1AH号中断，AH=1为”置时钟“
 MOV CX,0    ;设置入口参数，CH:CL=时：分
 MOV DX,0    ;设置入口参数，DH:DL=秒：1/100分
 INT 1AH     ;调用1AH号中断
</code></pre>
  </li>
  <li>DOS中断
    <ul>
      <li>包含常用的功能程序，分别实现文件管理、存储管理、作业管理和设备管理等功能</li>
      <li>共用21H号中断入口，通过传参数的方式设置功能号，以选择执行不同功能模块的代码</li>
      <li>说明
        <ul>
          <li>DOS中断功能比BIOS中断更齐全、完整</li>
          <li>进一步屏蔽了设备的物理特性及其接口特性
            <pre><code class="language-x86asm"> MOV AH,6    ;设置功能号，DOS中断6号功能为屏幕输入输出
 MOV DL,'$'  ;设置入口参数，DL中放置待输出的字符
 INT 21H     ;调用DOS中断
</code></pre>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h1 id="第九讲-输入输出设备">第九讲 输入输出设备</h1>

<h2 id="输入输出接口的基本功能">输入输出接口的基本功能</h2>
<ol>
  <li>数据缓冲
    <ul>
      <li>解决CPU和外设之间的速度差距</li>
    </ul>
  </li>
  <li>提供联络信息
    <ul>
      <li>协调与同步数据交换过程</li>
    </ul>
  </li>
  <li>信号与模拟信号格式的转换
    <ul>
      <li>模/数、数/模转换、串/并、并/串转换，电平转换</li>
    </ul>
  </li>
  <li>设备选择</li>
  <li>中断管理</li>
  <li>可编程功能</li>
</ol>

<p>显卡、南桥芯片、并行接口电路</p>

<h2 id="输入输出接口的编址方式">输入输出接口的编址方式</h2>
<p>I/O端口</p>
<ul>
  <li>I/O接口内部包含一组称为<code class="highlighter-rouge">I/O端口</code>的寄存器</li>
  <li>每个I/O端口都需有自己的<code class="highlighter-rouge">端口地址</code>（或称端口号），以便CPU访问</li>
</ul>

<p>常见的I/O端口编址方式</p>
<ul>
  <li>I/O端口和存储器分开编址
    <ul>
      <li>I/O Mapped I/O</li>
      <li>x86</li>
    </ul>
  </li>
  <li>I/O端口和存储器统一编址
    <ul>
      <li>Memory Mapped I/O</li>
      <li>ARM，MIPS，POWER PC</li>
    </ul>
  </li>
</ul>

<p>I/O端口和存储器分开编址(x86指令)</p>
<ul>
  <li>IN指令（输入）
    <pre><code class="language-x86asm">IN AC,PORT
</code></pre>
  </li>
  <li>OUT指令（输出）
    <pre><code class="language-x86asm">OUT PORT,AC
</code></pre>
  </li>
  <li>端口地址为0~255
    <ul>
      <li>直接寻址，间接寻址（DX保存端口地址）</li>
    </ul>
  </li>
  <li>端口地址大于255
    <ul>
      <li>间接寻址（DX保存端口地址）</li>
    </ul>
  </li>
  <li>通过<code class="highlighter-rouge">M/IO信号</code>去指定存储器寻址还是I/O接口寻址（=0）</li>
</ul>

<p>I/O端口和存储器统一编址</p>
<ul>
  <li>优点
    <ul>
      <li>可以利用为存储器开发的丰富的指令</li>
      <li>简化内部结构，减少CPU引脚</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>存储地址空间减小</li>
      <li>指令执行时间长</li>
    </ul>
  </li>
</ul>

<p>I/O端口和存储器分开编址</p>
<ul>
  <li>优缺点与统一编址相对</li>
</ul>

<h2 id="输入输出的控制方式">输入输出的控制方式</h2>

<p>I/O控制方式的含义：CPU如何控制外设的数据传送</p>

<p>I/O控制方式的分类</p>
<ol>
  <li>程序控制方式
    <ol>
      <li>无条件传送方式
        <ul>
          <li>简单外设</li>
          <li>优点：控制程序简单；缺点：只适用于简单外设</li>
        </ul>
      </li>
      <li>程序查询传送方式
        <ul>
          <li>CPU通过执行一段程序，不断查询外设的工作状态</li>
          <li>在确定外设已经准备就绪时，才进行数据传送</li>
          <li>控制寄存器-&gt;IO缓冲寄存器和状态寄存器</li>
          <li>优点：更准确和可靠；缺点：查询外设状态占用了大量的时间</li>
        </ul>
      </li>
      <li>共同的优缺点
        <ul>
          <li>优点：对外设要求低，操作流程清晰</li>
          <li>缺点：由CPU进行数据传送操作，占用了宝贵的运算资源</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>中断控制方式</li>
  <li>直接存储器访问（DMA）方式</li>
</ol>

<h2 id="中断控制方式">中断控制方式</h2>

<p>优点：</p>
<ul>
  <li>CPU可以和外设并行工作，提高了工作效率</li>
  <li>外围设备具有申请服务的主动权</li>
  <li>一定程度上满足了I/O处理的实时性要求</li>
</ul>

<p>缺点：</p>
<ul>
  <li>外设和存储器之间的数据交换仍由CPU承担
    <ul>
      <li>使用数据传送指令，占用了宝贵的CPU运算资源</li>
      <li>数据要经过CPU中的通用寄存器中转，过程冗长</li>
    </ul>
  </li>
  <li>进入和退出中断服务程序，需要额外的指令</li>
</ul>

<h2 id="外部中断的处理过程">外部中断的处理过程</h2>

<p>外部中断，也称硬件终端</p>
<ul>
  <li>由CPU外部的中断请求信号启动的中断</li>
</ul>

<p>x86 CPU为外部中断提供两个引脚</p>
<ul>
  <li>NMI：非屏蔽中断
    <ul>
      <li>信号非常重要，不希望被屏蔽</li>
    </ul>
  </li>
  <li>INTR：可屏蔽中断
    <ul>
      <li>中断控制器连接多个外设
        <ul>
          <li>可编程中断控制器：PIC</li>
          <li>高级可编程中断控制器：APIC</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>可屏蔽中断的处理过程</p>
<ol>
  <li>外设发中断请求信号</li>
  <li>CPU完成现行指令，发出中断响应信号</li>
  <li>CPU读取中断类型码</li>
  <li>当前CS/IP/PSW压栈</li>
  <li>清除IF和TF</li>
  <li>取CS/IP新值</li>
  <li>转入中断服务程序</li>
  <li>开放中断（可选）</li>
  <li>IRET指令使旧的CS/IP/PSW弹出堆栈</li>
  <li>返回被中断的程序</li>
</ol>

<p>中断嵌套</p>

<h2 id="直接存储器访问方式dma">直接存储器访问方式（DMA）</h2>

<p>DMA</p>
<ul>
  <li>数据传送过程不需要CPU干预（不需要执行程序指令）</li>
  <li>由专门硬件控制电路控制，进行外设与存储器间直接数据传送</li>
  <li>该专门硬件控制电路称为DMA控制器，简称DMAC</li>
</ul>

<p>DMAC的基本工作步骤</p>
<ol>
  <li>CPU设置DMAC内部配置寄存器</li>
  <li>DMAC处于空闲等待状态</li>
  <li>I/O接口向DMAC发出DMA传送申请</li>
  <li>DMAC响应I/O接口的申请</li>
  <li>DMAC向I/O接口发起总线读传输</li>
  <li>DMAC向存储器发起总线写传输</li>
  <li>重复5~6直到本次DMA传送完成</li>
  <li>返回2，等待下一次DMA传送申请</li>
</ol>

<p>DMAC的主要配置参数</p>
<ul>
  <li>CPU设置DMAC内部配置寄存器，一般包括
    <ol>
      <li>源地址的初始值以及传送时地址增减方式</li>
      <li>目的地址的初始值以及传送时地址增减方式</li>
      <li>待传送数据的长度</li>
    </ol>
  </li>
</ul>

<p>阿塔纳索夫-贝瑞计算机（Atanasoff-Berry Computer，简称ABC）是法定的世界上第一台电子计算机，是爱荷华州立大学的约翰·文森特·阿塔纳索夫（John Vincent Atanasoff）和他的研究生克利福特·贝瑞（Clifford Berry）在1937年设计，不可编程，仅仅设计用于求解线性方程组，并在1942年成功进行了测试。</p>

<p>ENIAC是第二台计算机和第一台通用计算机。</p>


</body>
</html>