<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2017-11-06T15:10:19+08:00</updated><id>http://localhost:4000/blog/</id><title type="html">blog</title><entry><title type="html">Todo</title><link href="http://localhost:4000/blog/2017/10/01/todo.html" rel="alternate" type="text/html" title="Todo" /><published>2017-10-01T00:00:00+08:00</published><updated>2017-10-01T00:00:00+08:00</updated><id>http://localhost:4000/blog/2017/10/01/todo</id><content type="html" xml:base="http://localhost:4000/blog/2017/10/01/todo.html">&lt;p&gt;###待完成
关键路径（Critical Path）&lt;br /&gt;
    优先级限制下的并行任务调度&lt;br /&gt;
    //TODO&lt;br /&gt;
    相对最后期限下的并行任务调度&lt;br /&gt;
    //TODO&lt;/p&gt;

&lt;p&gt;基于队列的Bellman-Ford算法&lt;br /&gt;
    基于上轮放松过的顶点本轮才可能放松的认识，优化算法&lt;br /&gt;
    在V-1轮后会结束，不知为何
    //TODO&lt;/p&gt;

&lt;p&gt;负权重环的检测&lt;br /&gt;
    套汇&lt;br /&gt;
    //TODO&lt;/p&gt;

&lt;p&gt;约瑟夫问题的效率更高的算法&lt;/p&gt;

&lt;p&gt;后置运算的转换&lt;/p&gt;

&lt;p&gt;队列的顺序表实现 实指&lt;/p&gt;

&lt;p&gt;循环队列&lt;/p&gt;

&lt;p&gt;农夫过河问题&lt;/p&gt;

&lt;p&gt;五人提灯过独木桥&lt;/p&gt;

&lt;p&gt;索引优先队列&lt;/p&gt;

&lt;p&gt;先下沉后上浮的堆排序&lt;/p&gt;

&lt;p&gt;二叉搜索树的理解与实现&lt;/p&gt;

&lt;p&gt;Huffman树的理解与实现&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;为什么在最后一个数据送出之前发出预充电的命令？&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;忙等待（busy waiting）,自旋锁（spin lock）&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;多处理器&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.1
1.2
1.3
1.4
1.6
2.1
2.2(除2.2.8-2.2.10外)
2.3
2.4
2.5.2
10.2.5
11.3.1
11.4.3中的调度部分
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第四五六章quiz&lt;/p&gt;

&lt;p&gt;c链&lt;/p&gt;

&lt;p&gt;mesa管程&lt;/p&gt;

&lt;p&gt;成组链接法&lt;/p&gt;

&lt;p&gt;AOE网&lt;/p&gt;</content><author><name></name></author><summary type="html">###待完成 关键路径（Critical Path） 优先级限制下的并行任务调度 //TODO 相对最后期限下的并行任务调度 //TODO</summary></entry><entry><title type="html">String</title><link href="http://localhost:4000/blog/2017/10/01/string.html" rel="alternate" type="text/html" title="String" /><published>2017-10-01T00:00:00+08:00</published><updated>2017-10-01T00:00:00+08:00</updated><id>http://localhost:4000/blog/2017/10/01/string</id><content type="html" xml:base="http://localhost:4000/blog/2017/10/01/string.html">&lt;p&gt;//TODO&lt;br /&gt;
substring search（子字符串查找）&lt;br /&gt;
formal languages（形式语言）&lt;br /&gt;
finite automata（有限自动机）&lt;br /&gt;
data compression（数据压缩）&lt;/p&gt;

&lt;p&gt;Java的char是两个byte，因为他是unicode&lt;/p&gt;
&lt;h1 id=&quot;51-字符串排序-string-sorts&quot;&gt;5.1 字符串排序 String sorts&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;低位优先 least-significant-digit LSD&lt;/li&gt;
  &lt;li&gt;高位优先 most-significant-digit MSD&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;键索引计数法-key-indexed-counting&quot;&gt;键索引计数法 key-indexed counting&lt;/h2&gt;

&lt;p&gt;一种稳定的排序法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;频率统计&lt;/li&gt;
  &lt;li&gt;将频率转化为索引&lt;/li&gt;
  &lt;li&gt;数据分类&lt;/li&gt;
  &lt;li&gt;回写&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aux&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//计算出现频率&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]++;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//将频率转换为索引&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//将元素分类&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;aux&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()]++]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//回写&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aux&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;低位优先的字符串排序-lsd-string-sort&quot;&gt;低位优先的字符串排序 LSD string sort&lt;/h2&gt;

&lt;p&gt;用键索引计数法将定长字符串组&lt;code class=&quot;highlighter-rouge&quot;&gt;从右至左&lt;/code&gt;排序w次&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LSD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//通过前W个字符将a[]排序&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aux&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--){&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]++;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;aux&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)]++]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aux&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;高位优先的字符串排序-msd-string-sort&quot;&gt;高位优先的字符串排序 MSD string sort&lt;/h2&gt;

&lt;p&gt;在将一个字符串数组a[]排序时，首先根据它们的首字母用键索引计数法进行排序，然后（递归地）根据子数组中的字符串的首字母将子数组排序&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://algs4.cs.princeton.edu/51radix/&quot;&gt;课程链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三向字符串快速排序-three-way-string-quicksort&quot;&gt;三向字符串快速排序 Three-way string quicksort&lt;/h2&gt;

&lt;p&gt;在将字符串数组a[]排序时，根据它们的首字母进行三向切分，然后（递归地）将得到的三个子数组排序：一个含有所有首字母小于切分字符的字符串子数组，一个含有所有首字母等于切分字符的字符串的子数组（排序时忽略它们的首字母），一个含有所有首字母大于切分字符的字符串的子数组&lt;/p&gt;

&lt;h1 id=&quot;52-字典树-tries&quot;&gt;5.2 字典树 TRIES&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;每个节点都含有R条链接，其中R为字母表的大小&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;字典树一般都含有大量的空链接，因此在绘制一棵字典树时一般会忽略空链接&lt;/p&gt;

&lt;p&gt;每个节点都对应一个值，可以是空的也可以是符号表中的某个键所关联的值&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;查找&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;尾字符节点的值非空，命中&lt;/li&gt;
  &lt;li&gt;尾字符节点的值为空，未命中&lt;/li&gt;
  &lt;li&gt;查找的过程中有空链接，未命中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;插入&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;存在尾字符节点，更新&lt;/li&gt;
  &lt;li&gt;查找过程中有空链接，建立所有不存在的节点，并将值保存在尾节点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;查找所有键 collect()&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DFS遍历所有节点，并将所有字符串加入集合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通配符匹配 wildcard match&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;改造collect()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最长前缀&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;记录查找路径上最长键的长度&lt;/li&gt;
  &lt;li&gt;遇到空链接或被查找字符串结束时终止&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;删除&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在递归删除了某个节点x之后，如果该节点的值和所有的链接均为空则返回null，否则返回x&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;性质&quot;&gt;性质&lt;/h3&gt;

&lt;p&gt;字典树的形状与键的插入或删除无关：对于任意给定的一组键，其字典树都是唯一的&lt;/p&gt;

&lt;p&gt;查找未命中的成本与键的长度无关&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一棵字典树的链接总数在RN和RNw之间，其中w为键的平均长度&lt;/li&gt;
  &lt;li&gt;不要用其处理来自大型字母表的大量长键，空间消耗太大&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三向单词查找树-ternary-search-trieststs&quot;&gt;三向单词查找树 Ternary search tries（TSTs）&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;每个节点都含有一个字符、三条链接和一个值&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;三条链接，从左至右依次变大&lt;/p&gt;

&lt;p&gt;查找&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果键小于中儿子，则查找左儿子；若大于中儿子，则查找右儿子；若等于中儿子，则迭代下一字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;插入&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;存在尾字符节点，更新&lt;/li&gt;
  &lt;li&gt;查找过程中有空链接，建立所有不存在的节点，并将值保存在尾节点&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;性质-1&quot;&gt;性质&lt;/h3&gt;

&lt;p&gt;由N个平局长度为w的字符串构造的三向单词查找树中的链接总数在3N和3Nw之间&lt;/p&gt;

&lt;h1 id=&quot;53-子字符串查找-substring-search&quot;&gt;5.3 子字符串查找 SUBSTRING SEARCH&lt;/h1&gt;

&lt;p&gt;给定一段长度为N的文本和一个长度为M的模式字符串，在文本中找到一个和该模式相符的子字符串&lt;/p&gt;

&lt;h2 id=&quot;暴力字符串查找算法-brute-force-substring-search&quot;&gt;暴力字符串查找算法 Brute-force substring search&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;txt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;txt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++){&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;txt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;KMP算法 Knuth-Morris-Pratt substring search&lt;/p&gt;

&lt;p&gt;//TODO 很难理解&lt;/p&gt;

&lt;p&gt;Boyer-Moore substring search&lt;/p&gt;</content><author><name></name></author><summary type="html">//TODO substring search（子字符串查找） formal languages（形式语言） finite automata（有限自动机） data compression（数据压缩）</summary></entry><entry><title type="html">Sort</title><link href="http://localhost:4000/blog/2017/10/01/sort.html" rel="alternate" type="text/html" title="Sort" /><published>2017-10-01T00:00:00+08:00</published><updated>2017-10-01T00:00:00+08:00</updated><id>http://localhost:4000/blog/2017/10/01/sort</id><content type="html" xml:base="http://localhost:4000/blog/2017/10/01/sort.html">&lt;h3 id=&quot;选择排序selection-sort&quot;&gt;选择排序（Selection Sort）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;找出当前数组中的最小元素，将其与第一个元素交换；&lt;/li&gt;
  &lt;li&gt;对剩下的数组执行相同的操作；&lt;/li&gt;
  &lt;li&gt;直到需要进行操作的数组里只剩下一个元素&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;插入排序insertion-sort&quot;&gt;插入排序（Insertion Sort）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;将当前元素与前一个元素比较，若小于则交换，直到当前元素不小于前一个元素&lt;/li&gt;
  &lt;li&gt;特点：比较适宜处理逆序比较少的数列&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;希尔排序insertion-sort&quot;&gt;希尔排序（Insertion Sort）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;确定一个增量序列，其最大值为h(比如Knuth增量序列)&lt;/li&gt;
  &lt;li&gt;对h有序数组进行插入排序；&lt;/li&gt;
  &lt;li&gt;h减1；若h小于0则停止；&lt;/li&gt;
  &lt;li&gt;重复第一个步骤；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;归并排序merge-sort&quot;&gt;归并排序（Merge Sort）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;先将两个子数组排序，在归并这两个子数组成一个大的数组&lt;/li&gt;
  &lt;li&gt;空间复杂度并非最优&lt;/li&gt;
  &lt;li&gt;标准的归并//TODO&lt;/li&gt;
  &lt;li&gt;自底向上(Bottom-up)的归并//TODO
    &lt;ul&gt;
      &lt;li&gt;特点：不使用递归，比较适合链表&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;快速排序quick-sort&quot;&gt;快速排序（Quick Sort）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;确定一个点的位置，对该点左右两子序列进行相同的操作，直到全部有序&lt;/li&gt;
  &lt;li&gt;特点：原地排序，不需要额外的存储空间&lt;/li&gt;
  &lt;li&gt;排过序的序列是最坏情况，n的平方&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;三向切分快速排序3-way-partition-quick-sort&quot;&gt;三向切分快速排序（3-way partition Quick Sort）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;特点：适用于重复元素比较多的序列&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二叉堆3-way-partition-quick-sort&quot;&gt;二叉堆（3-way partition Quick Sort）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树&lt;/li&gt;
  &lt;li&gt;堆的有序化（reheapifying）&lt;/li&gt;
  &lt;li&gt;若储存在数列中的完全二叉树从1开始，则对于当前节点k而言，其父节点（若有）为k/2，其左儿子（若有）为k&lt;em&gt;2，其右儿子（若有）为k&lt;/em&gt;2+1&lt;/li&gt;
  &lt;li&gt;若储存在数列中的完全二叉树从0开始，则对于当前节点k而言，其父节点（若有）为(k-1)/2，其左儿子（若有）为k&lt;em&gt;2+1，其右儿子（若有）为k&lt;/em&gt;2+2&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;堆排序heap-sort&quot;&gt;堆排序（Heap Sort）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;堆的构造：(复杂度O(n)&lt;/li&gt;
  &lt;li&gt;方法一：用swim从左到右扫描，保证已扫描过的数组是一个完全二叉树&lt;/li&gt;
  &lt;li&gt;方法二：从右向左sink每一个元素，因为一个元素是一个堆，所以可以跳过一般元素，从N/2(最后一个元素的父节点)开始向左扫描，这样比方法一更快&lt;/li&gt;
  &lt;li&gt;堆的排序：（复杂度O(nlgn)）
    &lt;ul&gt;
      &lt;li&gt;交换位置1与位置N的元素，缩小堆至N-1,继续执行以上步骤，直至堆的大小为1&lt;/li&gt;
      &lt;li&gt;总共的复杂度为O(nlgn)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;特点：
    &lt;ul&gt;
      &lt;li&gt;无论是堆的构建还是排序都只使用了sink，而没有使用swim；也有一种sink， then swim的堆排序方法&lt;/li&gt;
      &lt;li&gt;所知的唯一的能同时最优的利用空间和时间的方法&lt;/li&gt;
      &lt;li&gt;适用于内存比较紧张的情形，比如说嵌入式系统&lt;/li&gt;
      &lt;li&gt;现代系统很少利用它，因为它很少与邻近的元素比较，缓存命中的次数极低&lt;/li&gt;
      &lt;li&gt;若想得到升序，则建立大顶堆，若想得到降序，则建立小顶堆。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;各种排序的比较&quot;&gt;各种排序的比较&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;特点：只有插入排序和归并排序是稳定的，最广泛使用的是快速排序&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;imgs/sortcompare.png&quot; alt=&quot;排序比较&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">选择排序（Selection Sort） 找出当前数组中的最小元素，将其与第一个元素交换； 对剩下的数组执行相同的操作； 直到需要进行操作的数组里只剩下一个元素</summary></entry><entry><title type="html">Search</title><link href="http://localhost:4000/blog/2017/10/01/search.html" rel="alternate" type="text/html" title="Search" /><published>2017-10-01T00:00:00+08:00</published><updated>2017-10-01T00:00:00+08:00</updated><id>http://localhost:4000/blog/2017/10/01/search</id><content type="html" xml:base="http://localhost:4000/blog/2017/10/01/search.html">&lt;ul&gt;
  &lt;li&gt;符号表（symbol table）又被称为字典（dictionary），索引&lt;/li&gt;
  &lt;li&gt;二叉查找树，红黑树，散列表&lt;/li&gt;
  &lt;li&gt;递归的实现更容易验证其正确性，而非递归实现效率更高&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;符号表的实现&quot;&gt;符号表的实现&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;包含键值对的链表，无论是put还是get都是无顺序查找
    &lt;ul&gt;
      &lt;li&gt;像一个空表中插入n个不同的键需要N^2次比较&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有序数组，当插入和查询的时候利用二分查找确认位置
    &lt;ul&gt;
      &lt;li&gt;插入很慢，因为每次插入的时候需要移动数组&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;二分查找树&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二分查找树binary-search-tree&quot;&gt;二分查找树（Binary Search Tree）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;每个节点包括一个左儿子，一个右儿子，一个键，一个值，一个结点计数器&lt;/li&gt;
  &lt;li&gt;对一个序列而言，有序的BST可能不止一棵，然后将BST投影到一根直线上，其必定是有序序列，即所有有序的BST在直线上的投影都是一致的
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;imgs/treepj.png&quot; alt=&quot;树的投影&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;无论是查找还是插入都是lgn，而且代码实现都很简单&lt;/li&gt;
  &lt;li&gt;但最坏情形为n，不可接受&lt;/li&gt;
  &lt;li&gt;实现有两个儿子的节点的删除最为困难&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;INSERT&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;若大于根节点，则插入右子树&lt;/li&gt;
  &lt;li&gt;若小于根节点，则插入左子树&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FLOOR&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;若小于根节点，则一定存在于左子树&lt;/li&gt;
  &lt;li&gt;若大于根节点，则可能存在于右子树&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;删除&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;若只有一个儿子，则用该儿子代替父亲即可&lt;/li&gt;
  &lt;li&gt;若有两个儿子，则用后继代替该点，再删除该后继（即右子树中的最小值）即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;散列表&quot;&gt;散列表&lt;/h3&gt;

&lt;p&gt;拉链法 separate chaining&lt;/p&gt;

&lt;p&gt;线性探测法 linear probing&lt;/p&gt;

&lt;p&gt;散列函数应该易于计算并且能够均匀分布所有的键&lt;/p&gt;

&lt;p&gt;对于每种类型的键我们都需要一个与之对应的散列函数&lt;/p&gt;

&lt;p&gt;除留余数法 modular hashing&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;选择大小为&lt;code class=&quot;highlighter-rouge&quot;&gt;素数M&lt;/code&gt;的数组，对于任意正整数k,计算k除以M的余数&lt;/li&gt;
  &lt;li&gt;由于我们需要的是数组的索引，所以可以将其符号位mask掉&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;浮点数&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果键是0到1之间的实数，将键表示为二进制然后使用除留余数法&lt;/li&gt;
  &lt;li&gt;java对于浮点数的默认方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;字符串&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Horner方法&lt;/li&gt;
  &lt;li&gt;java对于String的默认方法
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;组合键&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于Date类型
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;day&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;month&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;year&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java的约定&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;若equals为true,则hashcode相同&lt;/li&gt;
  &lt;li&gt;逆否命题：若hashcode不同，equals为false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;自定义hashcode&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;who&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;who&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有序性相关的操作&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;散列最主要的目的在于均匀地将键散布开来，因此在计算散列后键的顺序信息就丢失了&lt;/li&gt;
  &lt;li&gt;所以散列表不是合适的选择&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;开放地址散列表-open-addressing-hashing-method&quot;&gt;开放地址散列表 open-addressing hashing method&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;插入：若命中，则修改；若未命中，则移向下一个；若为空，则插入&lt;/li&gt;
  &lt;li&gt;搜索：若命中，则找到；若未命中，则移向下一个；若为空，则返回&lt;/li&gt;
  &lt;li&gt;删除：只是将键的位置置为空是不行的，这会导致此位置之后的元素无法找到
    &lt;ul&gt;
      &lt;li&gt;若存在，则置为空，同时对连续的非空后继做如下操作
        &lt;ul&gt;
          &lt;li&gt;置为空，重新插入&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;若不存在，则返回&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;不允许使用率达到1，因为此时未命中的查找会导致无限循环。为了性能，我们会调整大小来保证使用率在1/8和1/2之间，小于1/2时探测次数在1.5到2.5之间&lt;/li&gt;
  &lt;li&gt;调整大小(resize)：建立新开放地址散列表，重新插入&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;平衡查找树-balanced-search-trees&quot;&gt;平衡查找树 BALANCED SEARCH TREES&lt;/h3&gt;

&lt;h3 id=&quot;2-3查找树-2-3-search-trees&quot;&gt;2-3查找树 2-3 SEARCH TREES&lt;/h3&gt;

&lt;p&gt;任何空链接到根节点的路径长度都是相等的&lt;/p&gt;

&lt;p&gt;只有当根节点被分解为3个2-node时，所有空链接到根节点的路径长度才会加1&lt;/p&gt;

&lt;p&gt;和标准的二叉查找树由上向下生长不同，2-3树的生长是由下向上的&lt;/p&gt;

&lt;p&gt;2-node&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;含有一个键和两个链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3-node&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;含有两个键和三个链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都处于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查找&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;要判断一个键是否在树中，我们先将它和根节点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;插入&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;若止于2-node，则将其变为3-node即可&lt;/li&gt;
  &lt;li&gt;若止于3-node
    &lt;ol&gt;
      &lt;li&gt;若该节点为根节点，则变为4-node，做局部变换（高度+1）&lt;/li&gt;
      &lt;li&gt;若该节点的父节点为2-node，先变为4-node，做局部变换，使父节点变为3-node
        &lt;ul&gt;
          &lt;li&gt;有左右儿子两种情况&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;若该节点的父节点为3-node，先变为4-node，做局部变换，使父节点变为4-node，继续对父节点做局部变换，直至遇到2-node，或者遇到根节点
        &lt;ul&gt;
          &lt;li&gt;有左中右儿子三种情况&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;红黑树-red-black-bsts&quot;&gt;红黑树 Red-Black BSTs&lt;/h3&gt;

&lt;p&gt;基本思想：用标准的二叉查找树和一些额外的信息表示2-3树&lt;/p&gt;

&lt;p&gt;替换3-node&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将3-node表示为一条左斜的红色链接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;或者说&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;红链接均为左链接&lt;/li&gt;
  &lt;li&gt;没有任何一个节点同时和两条红链接相连&lt;/li&gt;
  &lt;li&gt;该树是完美黑色平衡的，即任意空链接到根节点的路径上的黑链接数量相同&lt;/li&gt;
  &lt;li&gt;满足这样定义的红黑树和相应的2-3树是一一对应的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;颜色&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个节点都只有一条指向自己的链接，我们将链接的颜色当作自己的颜色；若为空链接，则为黑节点。例如，若指向自己的是红链接，则称该节点为红节点&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RED&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLACK&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isRed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RED&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;旋转&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在某些操作的过程中，可能会出现红色右链接和两条连续的红链接&lt;/li&gt;
  &lt;li&gt;左旋转 left rotation
    &lt;ul&gt;
      &lt;li&gt;若指向的节点的右链接是红色的，该操作会对树进行必要的调整并返回一个指向包含同一组键的子树且其左链接为红色的根节点的链接&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;右旋转 right rotation
    &lt;ul&gt;
      &lt;li&gt;类似于左链接&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;向2-node中插入新键&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;若新键小于老键，新增红色节点&lt;/li&gt;
  &lt;li&gt;若新键大于老键，左旋转&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;向一棵双键树（即3-node）中插入新键&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;若新键最大，则最小最大键涂黑，中键涂红&lt;/li&gt;
  &lt;li&gt;若新键最小，则先将右旋转最大键，然后最小最大键涂黑，中键涂红&lt;/li&gt;
  &lt;li&gt;若新键居中，则先左旋转最小键，再右旋转最大键，然后最小最大键涂黑，中键涂红&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;根节点总是黑色&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;红色的根节点说明根节点是一个3-node的一部分，然而实际情况并不是这样。因此我们每次在插入后都会将根节点设为黑色，每当根节点由红变黑时树的黑链接高度就会加1&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;删除&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;删除&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;自顶向下的2-3-4树&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将4-node表示为三个2-node组成的一棵平衡的子树，根节点和两个子节点都用红链接&lt;/li&gt;
  &lt;li&gt;在向下的过程中分解所有4-node并进行颜色转换&lt;/li&gt;
  &lt;li&gt;和插入操作一样，在向上的过程中用旋转将4-节点&lt;code class=&quot;highlighter-rouge&quot;&gt;配平&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;删除最小键&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果当前节点的左子节点不是2-节点，完成；&lt;/li&gt;
  &lt;li&gt;如果当前节点的左子节点是2-节点而它的亲兄弟节点不是2-节点，将当前节点的最小键移到左子节点中，将左子节点的兄弟节点的最小键移到当前节点中&lt;/li&gt;
  &lt;li&gt;如果当前节点的左子节点和他的亲兄弟节点都是2-节点，将左子节点、父节点中的最小键和左子节点最近的兄弟节点合并为一个4-节点，使父节点由3-节点变为2-节点或者由4-节点变为3-节点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;删除操作&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果被查找的键在树的底部，我们可以直接删除它&lt;/li&gt;
  &lt;li&gt;如果不在，我们需要将它和它的后继节点交换，就和二叉查找树一样&lt;/li&gt;
  &lt;li&gt;因为当前节点必然不是2-节点，问题已经转化为在一棵根节点不是2-节点的子树中删除最小的键。和之前一样，删除之后我们需要向上回溯并分解余下的4-节点&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">符号表（symbol table）又被称为字典（dictionary），索引 二叉查找树，红黑树，散列表 递归的实现更容易验证其正确性，而非递归实现效率更高</summary></entry><entry><title type="html">清华大学操作系统笔记</title><link href="http://localhost:4000/blog/operating/system/2017/10/01/osmore.html" rel="alternate" type="text/html" title="清华大学操作系统笔记" /><published>2017-10-01T00:00:00+08:00</published><updated>2017-10-01T00:00:00+08:00</updated><id>http://localhost:4000/blog/operating/system/2017/10/01/osmore</id><content type="html" xml:base="http://localhost:4000/blog/operating/system/2017/10/01/osmore.html">&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;并发&lt;/strong&gt;是指两个或多个事件在同一时间间隔内发生。
    &lt;ul&gt;
      &lt;li&gt;注意同一时间间隔（并发）和同一时刻（并行）的区别。&lt;/li&gt;
      &lt;li&gt;举例：在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每一时刻，单处理机环境下实际仅能有一道程序执行，故微观上这些程序还是在分时地交替执行。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;计算机开机后，操作系统最终被加载到&lt;strong&gt;RAM&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;我们把一段时间内只允许一个进程访问的资源称为&lt;strong&gt;临界资源&lt;/strong&gt;或&lt;strong&gt;独占资源&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;批处理操作系统、分时操作系统和实时操作系统各有什么特点？
    &lt;ol&gt;
      &lt;li&gt;批处理操作系统的用户脱机使用计算机，作业是成批处理的，系统内多道程序并发执行，交互能力差&lt;/li&gt;
      &lt;li&gt;分时操作系统可以让多个用户同时使用计算机，人机交互性较强，具有每个用户独立使用计算机的独占性，系统响应及时。&lt;/li&gt;
      &lt;li&gt;实时操作系统能对控制对象作出及时反应，可靠性高，响应及时，但是资源利用率低。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;甘特图画出&lt;strong&gt;逻辑控制流Logical Control Flow&lt;/strong&gt;图&lt;/li&gt;
  &lt;li&gt;访管指令&lt;/li&gt;
  &lt;li&gt;中断处理和子程序调用都需要压栈以保护现场，中断处理一定会保存而子程序调用不需要保存其内容的是&lt;strong&gt;程序状态字寄存器PSW&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;程序状态字PSW有一系列标志位，典型的有IF（Interrupt Flag）。在一些计算机结构是&lt;strong&gt;状态寄存器SR&lt;/strong&gt;和&lt;strong&gt;程序计数器PC&lt;/strong&gt;的结合体。&lt;/li&gt;
  &lt;li&gt;异常可以分为4类，中断(Interrupt)，陷阱(Trap)，故障(Fault)，终止(Abort)。&lt;/li&gt;
  &lt;li&gt;典型的陷阱有read、fork、execve、exit，处理器提供了一条特殊的“syscall n”指令用以调用它们；典型的故障有缺页异常；典型的终止有DRAM或SRAM损坏时发生的奇偶错误&lt;/li&gt;
  &lt;li&gt;对于x86-64系统而言，有高达256种不同的异常类型。其中0~32的号码对应Intel架构师定义的异常，因此对任何x86-64系统都是一样的；32~255的号码对应的是操作系统定义的中断和陷阱&lt;/li&gt;
  &lt;li&gt;在x86-64系统中，Linux系统调用的参数通过&lt;strong&gt;通用寄存器&lt;/strong&gt;而不是栈来传递。按照惯例，寄存器%rax包含系统调用号，寄存器&lt;strong&gt;%rdi、%rsi、%rdx、%r10、%r8、%r9&lt;/strong&gt;包含参数，显然最多可有6个参数。当系统调用返回时&lt;strong&gt;%rax&lt;/strong&gt;包含返回值，-4095到-1之间的负数表明发生了错误，对应于负的&lt;strong&gt;errno&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;中断隐指令&lt;/strong&gt;：CPU响应中断之后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，被称之为中断隐指令。中断隐指令并不指指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种不允许、也不可能为用户使用的特殊指令。其所完成的操作主要有：
    &lt;ol&gt;
      &lt;li&gt;保存断点&lt;/li&gt;
      &lt;li&gt;关中断&lt;/li&gt;
      &lt;li&gt;引出中断服务程序&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;对于私有地址空间而言，代码段总是从0x400000开始，0~0x400000保留给内核&lt;/li&gt;
  &lt;li&gt;Linux提高了一种聪明的机制，叫做&lt;strong&gt;/proc&lt;/strong&gt;文件系统，它允许用户模式进程访问内核数据结构的内容。你可以用它来找出系统属性，比如CPU类型(/proc/cpuinfo)，或者某个特殊的进程使用的内存段（/proc/&lt;process-id&gt;/maps)。2.6版本的的Linux内核引入**/sys**文件系统，提供关于系统总线和设备的额外信息。&lt;/process-id&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;fork函数&lt;/strong&gt;只被调用一次，却会返回两次：一次在父进程中，一次在子进程中；返回给父进程子进程的pid，返回给子进程0。&lt;/li&gt;
  &lt;li&gt;当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程&lt;strong&gt;回收(reaped)&lt;/strong&gt;。一个终止了但还未被回收的进程称为&lt;strong&gt;僵死进程（zombie）&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;如果一个父进程终止了，内核会安排init进程称为它的孤儿进程的养父。init进程的PID为1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。&lt;/li&gt;
  &lt;li&gt;一个进程可以通过调用&lt;strong&gt;waitpid&lt;/strong&gt;函数来等待它的子进程终止或者停止。waitpid挂起调用进程的执行，直到它的&lt;strong&gt;等待集合（wait set)&lt;/strong&gt;中的一个子进程终止。对于第一个参数pid而言，若针对特定子进程A，则其为A的pid；若针对全体子进程，则其为-1。第二个参数用于检查已回收子进程的退出状态。第三个参数用于修改waitpid的默认行为。第二、三个参数较为复杂，不赘述。
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waitpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statusp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;wait函数&lt;/strong&gt;是waitpid函数的简单版本，它等价于waitpid(-1, &amp;amp;status, 0)
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statusp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;命令行尾部的&lt;strong&gt;&amp;amp;符号&lt;/strong&gt;表示命令在后台执行&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;sleep函数&lt;/strong&gt;将一个进程挂起一段指定的时间
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;pause函数&lt;/strong&gt;使调用函数休眠，直到该进程收到了一个信号&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;execve函数&lt;/strong&gt;在当前进程的上下文中加载并运行一个新程序
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;execve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;envp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;只有当出现错误时，execve才会返回到调用程序，否则决不返回。&lt;/li&gt;
  &lt;li&gt;fork与execve的区别
    &lt;ul&gt;
      &lt;li&gt;fork函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品，只是pid不一样。execve函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然有相同的pid，并且继承了调用execve函数时已打开的所有文件描述符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;四个原语：创建进程原语，终止进程原语，阻塞进程原语，唤醒原语&lt;/li&gt;
  &lt;li&gt;分时系统采用时间片轮转发调度进程策略&lt;/li&gt;
  &lt;li&gt;一个&lt;strong&gt;进程实体&lt;/strong&gt;由程序段、相关数据段和PCB三部分构成&lt;/li&gt;
  &lt;li&gt;进程通信（IPC,Inter-Process Communication）的方法有三个：共享存储，消息传递，和管道通信
    &lt;ol&gt;
      &lt;li&gt;两个进程共享空间必须通过&lt;strong&gt;特殊的系统调用&lt;/strong&gt;来实现。&lt;/li&gt;
      &lt;li&gt;信息传递可以用&lt;strong&gt;发送信息&lt;/strong&gt;和&lt;strong&gt;接受信息&lt;/strong&gt;两个原语进行数据交换&lt;/li&gt;
      &lt;li&gt;管道通信是通过共享一个叫pipe的文件来实现，双方不能同时写或者读，因此只能采取&lt;strong&gt;半双工通信&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;CPU繁忙型进程可以理解为短进程&lt;/li&gt;
  &lt;li&gt;若某单处理器多进程系统中有多个就绪态进程，则下列关于处理机叙述正确的是
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A. 在进程结束时能进行处理机调度
B. 创建新进程后能进行处理机调度
C. 在进程处于临界区时不能进行处理机调度
D. 在系统调用完成并返回用户态时能进行处理机调度

ANSWER:C
对于C，当进程处于临界区时，说明进程正在占用处理机，只要不破坏临界资源的使用规则，是不会影响处理机调度的。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;“具有两道作业的批处理系统”就是说内存里面只能存放两道作业
    &lt;h3 id=&quot;同步互斥&quot;&gt;同步互斥&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;互斥（mutual exclusion）：一个进程占用资源，其他进程不能使用&lt;/li&gt;
      &lt;li&gt;死锁（deadlock）：多个进程各自占用部分资源，形成循环等待&lt;/li&gt;
      &lt;li&gt;饥饿（starvation)：其他进程可能轮流占用资源，一个进程一直得不到资源&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Peterson算法
    &lt;ul&gt;
      &lt;li&gt;共享变量
        &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;进入区代码
        &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dekkers算法&lt;/li&gt;
  &lt;li&gt;N线程的软件方法（Eisenberg和McGuire)&lt;/li&gt;
  &lt;li&gt;原子操作指令
    &lt;ol&gt;
      &lt;li&gt;现代CPU体系结构都提供一些特殊的原子操作指令&lt;/li&gt;
      &lt;li&gt;测试和置位（Test-and-Set）指令
        &lt;ul&gt;
          &lt;li&gt;从内存单元中读取值&lt;/li&gt;
          &lt;li&gt;测试该值是否为1（然后返回真或假）&lt;/li&gt;
          &lt;li&gt;内存单元值设置为1
            &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TestAndSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;交换指令（exchange）
        &lt;ul&gt;
          &lt;li&gt;交换内存中两个值&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;使用TS指令实现自旋锁(spinlock)
    &lt;ul&gt;
      &lt;li&gt;忙等待版本
    ```c++
    class Lock {
   int value = 0;
    }&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Lock::Acquire(){
    while(test-and-set(value))
        ; //spin
}

Lock::Release(){
    value = 0;
}
``` - 非忙等待版本
```c++
class Lock{
    int value = 0;
    WaitQueue q;
}

Lock::Acquire(){
    while(test-and-set(value)){
        add this TCB to wait queue q;
        schedule();
    }
}

Lock::Release(){
    value = 0;
    remove one thread t from q;
    wakeup(t);
}
``` ### 信号量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;信号量的实现
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;WaitQueue&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;信号量的分类
    &lt;ul&gt;
      &lt;li&gt;二进制信号量：资源数目为0或1&lt;/li&gt;
      &lt;li&gt;资源信号量：资源数目为任何非复值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;信号量的使用
    &lt;ul&gt;
      &lt;li&gt;互斥访问：临界区的互斥访问
        &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;条件同步：线程间的事件等待。举例如下，线程A要在线程B之后才能运行
        &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;//thread A
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;//thread B
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;生产者消费者问题
    &lt;ol&gt;
      &lt;li&gt;一个或多个生产者在生成数据后放在一个缓冲区里&lt;/li&gt;
      &lt;li&gt;单个消费者从缓冲区取出数据处理&lt;/li&gt;
      &lt;li&gt;任何时刻只能有一个生产者或消费者可访问缓冲区（互斥访问）&lt;/li&gt;
      &lt;li&gt;缓冲区空时，消费者必须等待生产者（条件同步）&lt;/li&gt;
      &lt;li&gt;缓冲区满时，生产者必须等待消费者（条件同步）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;生产者消费者问题的解决
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BoundedBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fullBuffers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;emptyBuffers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;BoundedBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;emptyBuffers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fullBuffers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;BoundedBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fullBuffers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;emptyBuffers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h3 id=&quot;管程monitor&quot;&gt;管程（Monitor）&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;管程是一种用于多线程互斥访问共享资源的程序结构
    &lt;ul&gt;
      &lt;li&gt;采用面向对象方法，简化了线程间的同步控制&lt;/li&gt;
      &lt;li&gt;任一时刻最多只有一个线程执行管程代码&lt;/li&gt;
      &lt;li&gt;正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;条件变量（Condition Variable）：每个条件变量表示一种等待原因，对应一个等待队列
    &lt;ul&gt;
      &lt;li&gt;Wait()操作
        &lt;ul&gt;
          &lt;li&gt;将自己阻塞在等待队列中&lt;/li&gt;
          &lt;li&gt;唤醒一个等待者或释放管程的互斥访问&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Signal()操作
        &lt;ul&gt;
          &lt;li&gt;将等待队列中的一个线程唤醒&lt;/li&gt;
          &lt;li&gt;如果等待队列为空，则等同空操作&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;管程的实现
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numWaiting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;WaitQueue&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Conditon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;numWaiting&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//need mutex
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Condition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numWaiting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//need mutex
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;numWaiting&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;用管程解决生产者-消费者问题
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BoundedBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Condition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;notFull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;notEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;BoundedBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;notFull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;notEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;BoundedBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;notEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;notFull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Hansen管程和Hoare管程
    &lt;ul&gt;
      &lt;li&gt;对于Hansen管程而言，进程B发出signal之后，wait的进程A并不立即执行，而是在进程B出了缓冲区之后A才执行&lt;/li&gt;
      &lt;li&gt;对于Hoare管程而言，进程B发出signal之后，wait的进程A立即执行，A出了缓冲区之后，B继续执行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Hansen管程和Hoare管程实现的区别
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Hansen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;notFull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;notEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Hoare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;notFull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;notEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;主要区别在count，对于Hansen管程而言，进程B发出了信号之后，继续执行，在执行的过程中，它可能会改变count，使得count继续为n，所以A要继续测试count == n。&lt;/li&gt;
      &lt;li&gt;对于Hoare管程而言，进程B发出了信号之后，暂停执行，所以count一定不为n，所以A不用再测试，继续往下执行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;哲学家就餐问题
    &lt;ul&gt;
      &lt;li&gt;五个哲学家围绕一张圆桌而坐&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;桌子上放着5只叉子&lt;/li&gt;
      &lt;li&gt;每两个哲学家之间放一支
      - 哲学家的动作包括思考和进餐&lt;/li&gt;
      &lt;li&gt;进餐时需同时拿到左右两边的叉子&lt;/li&gt;
      &lt;li&gt;思考时将两支叉子放回原处
        &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define N 5
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;semeaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;philosopher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;think&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;解决的主要问题是死锁，若是5个哲学家同时拿起左边的叉子，则陷入死锁。那么若不让他们拿起同一边的叉子，则不会出现那样的问题。在实现中，是通过每个哲学家的叉子的奇偶性来解决这一问题的。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;读者写者问题
    &lt;ul&gt;
      &lt;li&gt;“读-读”允许&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;同一时刻，允许有多个读者同时读
      - “读-写”互斥&lt;/li&gt;
      &lt;li&gt;没有写者时读者才能读&lt;/li&gt;
      &lt;li&gt;没有读者时写者才能写
      - “写-写”互斥&lt;/li&gt;
      &lt;li&gt;没有其他写者时写者才能写&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;读者写者问题的实现（写者优先，信号量版本）
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//Writer
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//Reader
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CountMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//只有第一个读者需要申请写锁
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rcount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CountMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CountMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rcount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CountMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;管程解决读者写者问题
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//Wait until no writers;
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;StartRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//check out - wake up waiting writers;
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;DoneRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StartRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;WR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;okToRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;WR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;AR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DoneRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;AR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;okToWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;check&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wakeup&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waiting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StartWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;WW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;okToWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;WW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;AW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DoneWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;AW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;okToWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;okToRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;broadcast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//管程的状态变量
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//of active readers
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//of active writers
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//of waiting readers
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//of waiting writers
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Condition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;okToRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Condition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;okToWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h3 id=&quot;死锁&quot;&gt;死锁&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;出现死锁的必要条件
    &lt;ul&gt;
      &lt;li&gt;互斥&lt;/li&gt;
      &lt;li&gt;持有并等待&lt;/li&gt;
      &lt;li&gt;非抢占：资源只能在进程使用后自愿释放&lt;/li&gt;
      &lt;li&gt;循环等待：存在等待进程集合{P&lt;sub&gt;0&lt;/sub&gt;,P&lt;sub&gt;1&lt;/sub&gt;,…,P&lt;sub&gt;N&lt;/sub&gt;}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;死锁处理方法
    &lt;ul&gt;
      &lt;li&gt;死锁预防（Deadlock Prevention)&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;确保系统永远不会进入死锁状态&lt;/li&gt;
      &lt;li&gt;预防是采用某种策略，限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的&lt;strong&gt;必要条件&lt;/strong&gt;。
      - 死锁避免（Deadlock Avoidance）&lt;/li&gt;
      &lt;li&gt;在使用前进行判断，只允许不会出现死锁的进程请求资源&lt;/li&gt;
      &lt;li&gt;当进程请求资源时，系统判断分配后是否处于安全状态
        &lt;ul&gt;
          &lt;li&gt;序列&amp;lt;P&lt;sub&gt;0&lt;/sub&gt;,P&lt;sub&gt;1&lt;/sub&gt;,…,P&lt;sub&gt;N&lt;/sub&gt;&amp;gt;是安全的
            &lt;ul&gt;
              &lt;li&gt;P&lt;sub&gt;i&lt;/sub&gt;要求的资源 &amp;lt;= 当前可用资源 + 所有P&lt;sub&gt;j&lt;/sub&gt;持有资源，其中j &amp;lt; i&lt;/li&gt;
              &lt;li&gt;死锁检测和恢复（Deadlock Detection &amp;amp; Recovery)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在检测到运行系统进入死锁状态后，进行恢复
      - &lt;strong&gt;由应用进程处理死锁&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;通常操作系统忽略死锁
        &lt;ul&gt;
          &lt;li&gt;大多数操作系统（包括UNIX）的做法
            &lt;h4 id=&quot;银行家算法bankers-algorithm&quot;&gt;银行家算法（Banker‘s Algorithm)&lt;/h4&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;银行家算法描述
    &lt;ul&gt;
      &lt;li&gt;银行家算法是一个&lt;strong&gt;避免死锁&lt;/strong&gt;的算法&lt;/li&gt;
      &lt;li&gt;客户在第一次申请贷款时，声明所需最大资金量，在满足所有贷款要求并完成项目时，及时归还&lt;/li&gt;
      &lt;li&gt;在客户贷款数量不超过银行拥有的最大值时，银行尽量满足客户需要&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;银行家算法的实现
    &lt;ul&gt;
      &lt;li&gt;n：系统中进程数量&lt;/li&gt;
      &lt;li&gt;m：资源类数量&lt;/li&gt;
      &lt;li&gt;Available[1…m]：每一种资源的资源数量&lt;/li&gt;
      &lt;li&gt;Max[1…n, 1…m]：每一个进程对某一类资源的最大的需求量&lt;/li&gt;
      &lt;li&gt;Allocation[1…n, 1…m]：当前系统中，哪些进程得到了哪些资源&lt;/li&gt;
      &lt;li&gt;Need[1…n, 1…m]：每一个进程还需要多少资源&lt;/li&gt;
      &lt;li&gt;Request[1…n, 1…m]：本次进程对资源的申请是多少&lt;/li&gt;
      &lt;li&gt;简记符号：&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;Available&lt;/li&gt;
      &lt;li&gt;Max[i]&lt;/li&gt;
      &lt;li&gt;Allocation[i]&lt;/li&gt;
      &lt;li&gt;Need[i]&lt;/li&gt;
      &lt;li&gt;Request[i]
      - 当进程P&lt;sub&gt;i&lt;/sub&gt;提出资源申请时，系统执行以下步骤
        &lt;ol&gt;
          &lt;li&gt;若Request[i] &amp;lt;= Need[i]，转2；否则报错返回&lt;/li&gt;
          &lt;li&gt;若Request[i] &amp;lt;= Available，转3；否则进程等待&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;假设系统分配了资源&lt;/strong&gt;，则有：
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Available = Available - Request[i];
  Allocation[i] = Allocation[i] + Request[i];
  Need[i] = Need[i] - Request[i];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
        &lt;ul&gt;
          &lt;li&gt;若系统新状态是安全的，则分配完成&lt;/li&gt;
          &lt;li&gt;若系统新状态是不安全的，则恢复原来状态，进程等待
            &lt;ul&gt;
              &lt;li&gt;为进行安全性检查，定义数据结构：&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Work: ARRAY[1…m] of integer；&lt;/li&gt;
      &lt;li&gt;Finish: ARRAY[1…n] of Boolean；&lt;/li&gt;
      &lt;li&gt;步骤：
        &lt;ol&gt;
          &lt;li&gt;Work = Available; Finish = false;&lt;/li&gt;
          &lt;li&gt;寻找满足条件的进程i，如果不存在转到条件4
            &lt;ol&gt;
              &lt;li&gt;Finish[i] == false;&lt;/li&gt;
              &lt;li&gt;Need[i] &amp;lt;= Work;&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;Work = Work + Allocation; Finish[i] = true;继续处理下一个进程&lt;/li&gt;
          &lt;li&gt;若对所有i,Finish[i] == true,则系统处于安全状态，否则系统处于不安全状态&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;死锁检测&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;允许系统进入死锁状态&lt;/li&gt;
      &lt;li&gt;维护资源分配图&lt;/li&gt;
      &lt;li&gt;定期调用死锁检查算法检测是否存在死锁&lt;/li&gt;
      &lt;li&gt;没有&lt;strong&gt;Max[i]&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;有&lt;strong&gt;Available&lt;/strong&gt;和&lt;strong&gt;Allocation&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;死锁检测算法&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
      &lt;li&gt;Work和Finish分别是长度为m和n的向量初始化
        &lt;ol&gt;
          &lt;li&gt;Work = Available&lt;/li&gt;
          &lt;li&gt;Allocation[i] &amp;gt; 0时，Finish[i] = false; 否则，Finish[i] = true;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;寻找线程T&lt;sub&gt;i&lt;/sub&gt;满足：
        &lt;ol&gt;
          &lt;li&gt;Finish[i] = false;&lt;/li&gt;
          &lt;li&gt;Request&lt;sub&gt;i&lt;/sub&gt; &amp;lt;= Work，没有找到这样的i，转到4&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;Work = Work + Allocation[i], Finish[i] = true, 转到2&lt;/li&gt;
      &lt;li&gt;如某个Finish[i] == false， 系统处于死锁状态
     - 算法需要O(m x n&lt;sup&gt;2&lt;/sup&gt;)操作检测是否系统处于死锁&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;死锁检测算法的使用
    &lt;ol&gt;
      &lt;li&gt;死锁检测的时间和周期选择依据
        &lt;ol&gt;
          &lt;li&gt;死锁多久可能发生&lt;/li&gt;
          &lt;li&gt;多少进程需要回滚&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;资源图可能有多少个循环
        &lt;ul&gt;
          &lt;li&gt;难于分辨“造成”死锁的关键进程&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;死锁恢复：进程终止
    &lt;ol&gt;
      &lt;li&gt;终止所有死锁进程&lt;/li&gt;
      &lt;li&gt;一次只终止一个进程直到死锁消除&lt;/li&gt;
      &lt;li&gt;终止进程的顺序应该是
        &lt;ol&gt;
          &lt;li&gt;进程的优先级&lt;/li&gt;
          &lt;li&gt;进程已运行时间以及还需运行时间&lt;/li&gt;
          &lt;li&gt;进程已占用资源&lt;/li&gt;
          &lt;li&gt;进程完成需要的资源&lt;/li&gt;
          &lt;li&gt;终止进程数目&lt;/li&gt;
          &lt;li&gt;进程是交互还是批处理&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;死锁恢复：资源抢占
    &lt;ul&gt;
      &lt;li&gt;选择被抢占进程
        &lt;ul&gt;
          &lt;li&gt;最小成本目标&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;进程回退
        &lt;ul&gt;
          &lt;li&gt;返回到一些安全状态，重启进程到安全状态&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;可能出现饥饿
        &lt;ul&gt;
          &lt;li&gt;同一进程可能一直被选作被抢占者
            &lt;h3 id=&quot;进程通信ipcinter-process-communication&quot;&gt;进程通信（IPC,Inter-Process Communication）&lt;/h3&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;进程通信是进程进行通信和同步的机制&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;IPC提供2个基本操作
        &lt;ul&gt;
          &lt;li&gt;发送操作：send(message)&lt;/li&gt;
          &lt;li&gt;接收操作：receive(message)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;进程通信流程
        &lt;ul&gt;
          &lt;li&gt;在通信进程间建立通信链路&lt;/li&gt;
          &lt;li&gt;通过send/receive交换信息&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;进程链路特征
        &lt;ul&gt;
          &lt;li&gt;物理（如，共享内存，硬件总线）&lt;/li&gt;
          &lt;li&gt;逻辑（如，逻辑属性）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;信号（参考CSAPP,signal.h）&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;进程间的软件中断通知和处理机制&lt;/li&gt;
      &lt;li&gt;如：SIGKILL,SIGSTOP,SIGCONT等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;信号(Signal)的接收处理
    &lt;ul&gt;
      &lt;li&gt;捕获(catch)：执行进程指定的信号处理函数被调用&lt;/li&gt;
      &lt;li&gt;忽略(ignore)：执行操作系统指定的缺省处理
        &lt;ul&gt;
          &lt;li&gt;例如：进程终止、进程挂起等&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;屏蔽（Mask）：禁止进程接收和处理信号
        &lt;ul&gt;
          &lt;li&gt;可能使暂时的（当处理同样类型的信号）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;不足
        &lt;ul&gt;
          &lt;li&gt;传送的信息量小，只有一个信号类型&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;外中断也叫硬中断，内中断也叫软终端&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;管道（pipe）&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;进程间基于&lt;strong&gt;内存文件&lt;/strong&gt;的通信机制
        &lt;ul&gt;
          &lt;li&gt;子进程从父进程继承文件描述符&lt;/li&gt;
          &lt;li&gt;缺省文件描述符：0 stdin, 1 stdout, 2 stderr&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;进程不知道（或不关心）的另一端
        &lt;ul&gt;
          &lt;li&gt;可能从键盘、文件、程序读取&lt;/li&gt;
          &lt;li&gt;可能写入到终端、文件、程序&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;与管道相关的系统调用
        &lt;ul&gt;
          &lt;li&gt;读管道：read(fd, buffer, nbytes)， scanf()是基于它实现的&lt;/li&gt;
          &lt;li&gt;写管道：write(fd, buffer, nbytes)， printf()是基于它实现的&lt;/li&gt;
          &lt;li&gt;创建管道：pipe(rgfd)
            &lt;ul&gt;
              &lt;li&gt;rgfd是2个文件描述符组成的数组&lt;/li&gt;
              &lt;li&gt;rgfd[0]是读文件描述符&lt;/li&gt;
              &lt;li&gt;rgfd[1]是写文件描述符&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;举例： % ls&lt;/td&gt;
              &lt;td&gt;more&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;消息队列 Message queue&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;每个消息(Message)是一个字节序列&lt;/li&gt;
      &lt;li&gt;相同标识的消息组成按先进先出顺序组成一个消息序列（Message Queues)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;消息队列的系统调用
    &lt;ul&gt;
      &lt;li&gt;msgget(key, flags) 获取消息队列标识&lt;/li&gt;
      &lt;li&gt;msgsnd(QID, buf, size, flags) 发送消息&lt;/li&gt;
      &lt;li&gt;msgrcv(QID, buf, size, type, flags) 接收消息&lt;/li&gt;
      &lt;li&gt;msgctl(…) 消息队列控制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;共享内存 Shared memory&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;是把同一物理内存区域同时映射到多个进程的内存地址空间的通信机制&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;进程&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;每个进程都有私有内存地址空间&lt;/li&gt;
      &lt;li&gt;每个进程的内存地址空间需明确设置&lt;strong&gt;共享内存段&lt;/strong&gt;
      - 线程&lt;/li&gt;
      &lt;li&gt;同一进程中的线程总是共享相同的内存地址空间
      - 优点：方便、快速地共享数据,速度是最快的
      - 缺点：必须用额外的同步机制来协调数据访问，需要由程序员提供同步&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;共享内存系统调用
    &lt;ul&gt;
      &lt;li&gt;shmget(key, size, flags)：创建共享段&lt;/li&gt;
      &lt;li&gt;shmat(shmid, *shmaddr, flags)：把共享段映射到进程地址空间&lt;/li&gt;
      &lt;li&gt;shmdt(*shmaddr)：取消共享段到进程地址空间的映射&lt;/li&gt;
      &lt;li&gt;shmctl(…)：共享段控制&lt;/li&gt;
      &lt;li&gt;需要信号量等机制协调共享内存的访问冲突
        &lt;h3 id=&quot;物理内存管理连续内存分配&quot;&gt;物理内存管理：连续内存分配&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;存储管理需要实现四大目标：
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;抽象&lt;/strong&gt;：逻辑地址空间&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;保护&lt;/strong&gt;：独立地址空间&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;共享&lt;/strong&gt;：访问相同内存&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;虚拟化&lt;/strong&gt;：更大的地址空间&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;操作系统中采用的内存管理方式
    &lt;ol&gt;
      &lt;li&gt;重地位（relocation）：段地址+偏移&lt;/li&gt;
      &lt;li&gt;分段（segmentation)：代码段，数据段，堆栈&lt;/li&gt;
      &lt;li&gt;分页（paging）：最小的单元&lt;/li&gt;
      &lt;li&gt;虚拟存储（virtual memory)：目前多数系统（如linux）采用按需页式虚拟存储&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;实现高度依赖硬件
    &lt;ol&gt;
      &lt;li&gt;与计算机存储架构紧耦合&lt;/li&gt;
      &lt;li&gt;MMU（内存管理单元）：处理CPU存储访问请求的硬件&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;地址生成时机和限制
    &lt;ol&gt;
      &lt;li&gt;编译时
        &lt;ul&gt;
          &lt;li&gt;假设起始地址已知&lt;/li&gt;
          &lt;li&gt;如果起始地址改变，必须重新编译&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;加载时
        &lt;ul&gt;
          &lt;li&gt;如编译时起始地址未知，编译器需生成可重定位代码&lt;/li&gt;
          &lt;li&gt;加载时，生成绝对地址&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;执行时
        &lt;ul&gt;
          &lt;li&gt;执行时代码可移动&lt;/li&gt;
          &lt;li&gt;需地址转换（映射）硬件支持&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;操作系统：&lt;strong&gt;建立逻辑地址LA和物理地址PA的映射&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;地址检查：操作系统设置&lt;strong&gt;段长度寄存器&lt;/strong&gt;和&lt;strong&gt;段基址寄存器&lt;/strong&gt;影响地址检查&lt;/li&gt;
  &lt;li&gt;连续内存分配：
    &lt;ul&gt;
      &lt;li&gt;内存碎片：空闲内存不能利用&lt;/li&gt;
      &lt;li&gt;外部碎片：分配单位之内的未被使用的内存&lt;/li&gt;
      &lt;li&gt;内部碎片：分配单元内部的未被使用内存，取决于分配单元大小是否要取整&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;动态分区分配：
    &lt;ul&gt;
      &lt;li&gt;需维护的数据结构
        &lt;ul&gt;
          &lt;li&gt;所有进程的已分配分区&lt;/li&gt;
          &lt;li&gt;空闲分区（Empty-blocks)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;动态分区分配策略
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;最先匹配 First-fit&lt;/strong&gt;：分配n个字节，使用第一个可用的空间比n大的空闲块&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;最佳匹配 Best-fit&lt;/strong&gt;：分配n字节，查找并使用不小于n的最小空闲分区&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;最差匹配 Worst-fit&lt;/strong&gt;：分配n字节，使用尺寸不下于n的最大空闲分区&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;碎片整理
    &lt;ul&gt;
      &lt;li&gt;紧凑 &lt;strong&gt;compaction&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;条件：所有的应用程序可以动态重定位
      - 分区对换 &lt;strong&gt;swapping in/out&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;抢占并回收处于等待状态进程的分区，以增大可用内存空间
        &lt;h3 id=&quot;伙伴系统&quot;&gt;伙伴系统&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;伙伴系统 Buddy System
    &lt;ol&gt;
      &lt;li&gt;整个可分配的分区大小2&lt;sup&gt;u&lt;/sup&gt;&lt;/li&gt;
      &lt;li&gt;需要的分区大小为2&lt;sup&gt;u&lt;/sup&gt;-1 &amp;lt; s ≤ 2&lt;sup&gt;u&lt;/sup&gt;时，把整个块分配给该进程
        &lt;ul&gt;
          &lt;li&gt;如s ≤ 2&lt;sup&gt;i - 1&lt;/sup&gt;，将大小为2&lt;sup&gt;i&lt;/sup&gt;的当前空闲分区划分成大小为2&lt;sup&gt;i - 1&lt;/sup&gt;的空闲分区&lt;/li&gt;
          &lt;li&gt;重复划分过程，直到2&lt;sup&gt;i - 1&lt;/sup&gt; &amp;lt; s ≤ 2&lt;sup&gt;i&lt;/sup&gt;，并把一个空闲分区分配给该进程&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;伙伴系统的数据结构
    &lt;ol&gt;
      &lt;li&gt;空闲块按大小和起始地址组织成二维数组&lt;/li&gt;
      &lt;li&gt;初始状态：只有一个大小为2&lt;sup&gt;u&lt;/sup&gt;的空闲块&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;伙伴系统的分配过程
    &lt;ol&gt;
      &lt;li&gt;由小到大在空闲块数组中找最小的可用空闲块&lt;/li&gt;
      &lt;li&gt;如果空闲块过大，对可用空闲块进行二等分，直到得到合适的可用空闲块&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;伙伴系统的合并条件
    &lt;ol&gt;
      &lt;li&gt;大小相同2&lt;sup&gt;i&lt;/sup&gt;&lt;/li&gt;
      &lt;li&gt;地址相邻&lt;/li&gt;
      &lt;li&gt;起始地址较小的块的起始地址必须是2&lt;sup&gt;i+1&lt;/sup&gt;的倍数
        &lt;h3 id=&quot;物理内存管理非连续内存分配&quot;&gt;物理内存管理：非连续内存分配&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;非连续分配的设计目标：提高内存利用效率和管理灵活性
    &lt;ul&gt;
      &lt;li&gt;允许一个程序的使用非连续的物理地址空间&lt;/li&gt;
      &lt;li&gt;允许共享代码与数据&lt;/li&gt;
      &lt;li&gt;支持动态加载和动态链接&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;非连续分配需要解决的问题
    &lt;ul&gt;
      &lt;li&gt;如何实现虚拟地址和物理地址的转换&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;软件实现（灵活，开销大）&lt;/li&gt;
      &lt;li&gt;硬件实现（够用，开销小）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;非连续分配的硬件辅助机制
    &lt;ul&gt;
      &lt;li&gt;如何选择非连续分配中的内存分块大小&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;段式存储管理&lt;/strong&gt;（segmentation）&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;页式存储管理&lt;/strong&gt;（paging）
        &lt;h3 id=&quot;段式存储管理&quot;&gt;段式存储管理&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;段式存储管理
    &lt;ul&gt;
      &lt;li&gt;进程的段地址空间由多个段组成&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;主代码段&lt;/li&gt;
      &lt;li&gt;子模式代码段&lt;/li&gt;
      &lt;li&gt;公用库代码段&lt;/li&gt;
      &lt;li&gt;堆栈段 stack&lt;/li&gt;
      &lt;li&gt;堆数据 heap&lt;/li&gt;
      &lt;li&gt;初始化数据段&lt;/li&gt;
      &lt;li&gt;符号表等
      - 段式存储管理的目的&lt;/li&gt;
      &lt;li&gt;更细粒度和灵活的分离与共享
      - 段的概念&lt;/li&gt;
      &lt;li&gt;段表示访问方式和存储数据等属性相同的一段地址空间&lt;/li&gt;
      &lt;li&gt;对应一个连续的内存“块”&lt;/li&gt;
      &lt;li&gt;若干个段组成进程逻辑地址空间
      - 段访问：逻辑地址由二元组(s, addr)表示&lt;/li&gt;
      &lt;li&gt;s - 段号&lt;/li&gt;
      &lt;li&gt;addr - 段内偏移
      - 段访问的硬件实现
      - &lt;img src=&quot;http://localhost:4000/blog/images/osm0.png&quot; alt=&quot;段访问的硬件实现&quot; /&gt;
        &lt;h3 id=&quot;页式存储管理&quot;&gt;页式存储管理&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;页式存储管理
    &lt;ul&gt;
      &lt;li&gt;页帧（帧、物理页面，Frame，Page Frame）&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;把物理地址空间划分为大小相同的基本分配单位&lt;/li&gt;
      &lt;li&gt;2的n次方，如512，4096，8192
      - 页面（页，逻辑页面，Page）&lt;/li&gt;
      &lt;li&gt;把逻辑地址空间也划分为相同大小的基本分配单位&lt;/li&gt;
      &lt;li&gt;帧和页的大小必须是相同的
      - 页面到页帧&lt;/li&gt;
      &lt;li&gt;逻辑地址到物理地址的转换&lt;/li&gt;
      &lt;li&gt;页表&lt;/li&gt;
      &lt;li&gt;MMU/TLB
      - 页帧Frame&lt;/li&gt;
      &lt;li&gt;物理内存被划分为大小相等的帧
        &lt;ul&gt;
          &lt;li&gt;内存物理地址的表示：&lt;strong&gt;二元组（f,o)&lt;/strong&gt;，f为帧号（F位，共有2&lt;sub&gt;F&lt;/sub&gt;个帧），表示偏移量；o为帧内偏移（S位，每帧有2&lt;sup&gt;s&lt;/sup&gt;字节）；物理地址 = f * 2&lt;sup&gt;s&lt;/sup&gt; + o
            &lt;ul&gt;
              &lt;li&gt;页Page&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;进程逻辑地址空间被划分为大小相等的页
        &lt;ul&gt;
          &lt;li&gt;页内偏移 = 帧内偏移&lt;/li&gt;
          &lt;li&gt;通常：页号大小 ≠ 帧号大小&lt;/li&gt;
          &lt;li&gt;进程逻辑地址的表示：&lt;strong&gt;二元组（p,o)&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;p –页号（P位，2&lt;sup&gt;P&lt;/sup&gt;个页）&lt;/li&gt;
          &lt;li&gt;o –页内偏移（S位，每页有2&lt;sup&gt;s&lt;/sup&gt;字节）&lt;/li&gt;
          &lt;li&gt;虚拟地址 = p * 2&lt;sup&gt;s&lt;/sup&gt; + o
            &lt;ul&gt;
              &lt;li&gt;页式存储中的地址映射&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;页&lt;/strong&gt;到&lt;strong&gt;帧&lt;/strong&gt;的映射&lt;/li&gt;
      &lt;li&gt;逻辑地址中的页号是&lt;strong&gt;连续&lt;/strong&gt;的&lt;/li&gt;
      &lt;li&gt;物理地址中的帧号是&lt;strong&gt;不连续&lt;/strong&gt;的&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;不是&lt;/strong&gt;所有的页都有&lt;strong&gt;对应&lt;/strong&gt;的帧
      - 所以求二元组(p, o) -&amp;gt; (f, o)的对应关系实际上试求p -&amp;gt; f的对应关系
      - p -&amp;gt; f的对应关系保存在页表中，而页表的地址是&lt;strong&gt;页表基址&lt;/strong&gt;
        &lt;h3 id=&quot;页表概述&quot;&gt;页表概述&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;每个进程都有一个页表
    &lt;ul&gt;
      &lt;li&gt;每个页面对应一个页表项&lt;/li&gt;
      &lt;li&gt;随进程运行状态而动态变化&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;页表基址寄存器（PTBR:Page Table Base Register)&lt;/strong&gt; 对于英特尔处理器而言，即为CR3&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;页表项的组成
    &lt;ul&gt;
      &lt;li&gt;帧号：f&lt;/li&gt;
      &lt;li&gt;页表项标志&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;存在位 resident bit ： 是否有物理帧&lt;/li&gt;
      &lt;li&gt;修改位 dirty bit ： 页面内容是否修改&lt;/li&gt;
      &lt;li&gt;引用位 clock/reference bit ： 是否访问过页面的某一个存储单元&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;页式存储的性能问题
    &lt;ul&gt;
      &lt;li&gt;内存访问性能问题&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;访问一个内存单元需要2次内存访问&lt;/li&gt;
      &lt;li&gt;第一次访问：获取页表项&lt;/li&gt;
      &lt;li&gt;第二次访问：访问数据
      * 页表大小问题：&lt;/li&gt;
      &lt;li&gt;页表可能非常大&lt;/li&gt;
      &lt;li&gt;64位机器如果每页1024字节，那么一个页表的大小会是多少？
      * 如何处理？&lt;/li&gt;
      &lt;li&gt;缓存（Caching）&lt;/li&gt;
      &lt;li&gt;间接（Indirection）访问
        &lt;h3 id=&quot;快表和多级页表&quot;&gt;快表和多级页表&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;快表（Translation Look-aside Buffer TLB）&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;缓存近期访问的页表项&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;TLB使用关联存储（associative memory）实现，具备快速访问功能&lt;/li&gt;
      &lt;li&gt;如果TLB命中，物理页号可以很快被获取&lt;/li&gt;
      &lt;li&gt;如果TLB未命中，对应的表项被更新到TLB中&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;多级页表&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;通过间接引用将页号分为k级&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;建立页表“树”&lt;/li&gt;
      &lt;li&gt;逻辑地址：&lt;strong&gt;k+1元组（p&lt;sub&gt;1&lt;/sub&gt;,p&lt;sub&gt;2&lt;/sub&gt;,…,p&lt;sub&gt;k&lt;/sub&gt;,o)&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;可以有效减少每一级页表的长度&lt;/li&gt;
      &lt;li&gt;二级页表实例&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://localhost:4000/blog/images/osm1.png&quot; alt=&quot;二级页表实例&quot; /&gt;
        &lt;h3 id=&quot;反置页表&quot;&gt;反置页表&lt;/h3&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  - 原因：对于大地址空间（64-bit）系统，多级页表变得**繁琐**
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;比如：5级页表&lt;/li&gt;
      &lt;li&gt;逻辑（虚拟）地址空间增长速度快于物理地址空间
      - &lt;strong&gt;页寄存器&lt;/strong&gt;和&lt;strong&gt;反置页面&lt;/strong&gt;的思路&lt;/li&gt;
      &lt;li&gt;不让页表与&lt;strong&gt;逻辑地址空间&lt;/strong&gt;的大小相对应&lt;/li&gt;
      &lt;li&gt;让页表与&lt;strong&gt;物理地址空间&lt;/strong&gt;的大小相对应
      - &lt;strong&gt;页寄存器 Page Registers&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;每个帧与一个页寄存器（Page Register）&lt;strong&gt;关联&lt;/strong&gt;，寄存器内容包括：
        &lt;ul&gt;
          &lt;li&gt;使用位（Residence bit）：此帧是否被进程占用&lt;/li&gt;
          &lt;li&gt;占用页号（Occupier)：对应的页号p，一知道该物理帧分配给了哪一个进程，逻辑地址是多少&lt;/li&gt;
          &lt;li&gt;保护位（Protection bits）:约定这一页的访问方式，比如可读可写&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;优点
        &lt;ul&gt;
          &lt;li&gt;页表大小相对于物理内存而言很小&lt;/li&gt;
          &lt;li&gt;页表大小与逻辑地址空间大小无关&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;缺点
        &lt;ul&gt;
          &lt;li&gt;页表信息对调后，需要依据帧号找到页号&lt;/li&gt;
          &lt;li&gt;在页寄存器中搜索逻辑地址中的页号
            &lt;ul&gt;
              &lt;li&gt;&lt;strong&gt;反置页表&lt;/strong&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;多了一个pid用于hash&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://localhost:4000/blog/images/osm2.png&quot; alt=&quot;反置页表&quot; /&gt;
        &lt;h3 id=&quot;段页式存储管理&quot;&gt;段页式存储管理&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;段页式存储管理的需求
    &lt;ul&gt;
      &lt;li&gt;段式存储在内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势&lt;/li&gt;
      &lt;li&gt;在段式存储管理基础上，给每个段加一级页表&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://localhost:4000/blog/images/osm3.png&quot; alt=&quot;段页式存储管理&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://localhost:4000/blog/images/osm4.png&quot; alt=&quot;段页式存储管理中的内存共享&quot; /&gt;
        &lt;h3 id=&quot;虚拟存储概念&quot;&gt;虚拟存储概念&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;覆盖与交换的比较
    &lt;ul&gt;
      &lt;li&gt;覆盖&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;只能发生在没有调用关系的模块间&lt;/li&gt;
      &lt;li&gt;程序员须给出模块间的逻辑覆盖结构&lt;/li&gt;
      &lt;li&gt;发生在运行程序的内部模块间
      - 交换&lt;/li&gt;
      &lt;li&gt;以进程为单位&lt;/li&gt;
      &lt;li&gt;不需要模块间的逻辑覆盖结构&lt;/li&gt;
      &lt;li&gt;发生在内存进程间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;局部性原理
    &lt;ul&gt;
      &lt;li&gt;程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期&lt;/li&gt;
      &lt;li&gt;空间局部性：当前指令和邻近的几条指令，当前访问过的数据和邻近的几个数据都集中在一个较小的区域内&lt;/li&gt;
      &lt;li&gt;分支局部性：一条跳转指令的执行，很可能跳到相同的内存位置
      - 意义：从理论上来说，虚拟存储技术是能够实现的，而且可以取得满意的效果&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;虚拟存储概念
    &lt;ul&gt;
      &lt;li&gt;思路：将不常用的内存块暂存到外存&lt;/li&gt;
      &lt;li&gt;支持技术：&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;硬件：页式或短时存储中的地址转换机制&lt;/li&gt;
      &lt;li&gt;操作系统：管理内存和外存间页面或段的换入和换出&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;虚拟页式存储&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;在页式存储管理的基础上，增加&lt;strong&gt;请求调页&lt;/strong&gt;和&lt;strong&gt;页面置换算法&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;页表项结构&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;访问位，修改位，保护位，驻留位，物理页帧号&lt;/li&gt;
      &lt;li&gt;驻留位：表示该页是否在内存&lt;/li&gt;
      &lt;li&gt;修改位：表示在内存中的该页是否被修改过；回收该物理页面时，据此判断是否要把它的内容写回外存&lt;/li&gt;
      &lt;li&gt;访问位：表示该页面是否被访问过（读或写）；用于&lt;strong&gt;页式置换算法&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;保护位：表示该页允许的访问方式：只读、可读写、可执行等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;缺页异常&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;http://localhost:4000/blog/images/osm5.png&quot; alt=&quot;缺页异常&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;虚拟页式存储管理的性能
        &lt;ul&gt;
          &lt;li&gt;有效存储访问时间 effective memory access time EAT
            &lt;ul&gt;
              &lt;li&gt;EAT = 访存时间 * (1 - p) + 缺页异常处理时间 * 缺页率p
                &lt;h3 id=&quot;页面置换算法-page-replacement-algorithm&quot;&gt;页面置换算法 Page replacement algorithm&lt;/h3&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;页面锁定 frame locking
    &lt;ul&gt;
      &lt;li&gt;描述必须常驻内存的逻辑页面&lt;/li&gt;
      &lt;li&gt;操作系统的关键部分&lt;/li&gt;
      &lt;li&gt;要求响应速度的代码和数据&lt;/li&gt;
      &lt;li&gt;页表中的锁定标志位lock bit&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;局部页面置换算法&lt;/strong&gt;
    - 置换页面的选择范围&lt;strong&gt;仅限于当前进程&lt;/strong&gt;占用的物理页面内
    - 最优算法（没法实现）、先进先出算法 FIFO（性能不好）、最近最久未使用算法 LRU Least Recently Used（比较复杂，开销大）
    - 时钟算法 Clock、最不常用算法 LFU Least Frequently Used，都是&lt;strong&gt;最近最久未使用算法的近似&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;全局页面置换算法&lt;/strong&gt;
    - 置换页面的选择范围是所有可换出的物理页面
    - 工作集算法，缺页率算法&lt;/li&gt;
  &lt;li&gt;先进先出算法 FIFO 属于局部页面置换算法
    - 选择在&lt;strong&gt;内存驻留时间最长&lt;/strong&gt;的页面进行置换
    - 可能会导致Belady现象&lt;/li&gt;
  &lt;li&gt;最近最久未使用算法 LRU Least Recently Used 属于局部页面置换算法
    - 选择最长时间没有被引用的页面进行置换
    - 假设：&lt;strong&gt;如果某些页面长时间未被访问，则它们在将来还可能会长时间不会访问&lt;/strong&gt;
    - 开销大&lt;/li&gt;
  &lt;li&gt;时钟页面置换算法 关键词：访问位，修改位 属于局部页面置换算法 需要理解
    &lt;ul&gt;
      &lt;li&gt;思路：仅对页面的访问情况进行大致统计&lt;/li&gt;
      &lt;li&gt;在页表项中增加&lt;strong&gt;访问位&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;各页面组织成&lt;strong&gt;环形链表&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;指针&lt;/strong&gt;指向最先调用的页面？&lt;/li&gt;
      &lt;li&gt;算法：
        &lt;ul&gt;
          &lt;li&gt;页面装入内存时，访问位初始化为0&lt;/li&gt;
          &lt;li&gt;访问页面（读/写）时，访问位置为1&lt;/li&gt;
          &lt;li&gt;缺页时，访问位为0，则置换该页；访问位为1，置为0，从下一个页面开始找&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;改进：减少修改页的缺页处理开销
        &lt;ul&gt;
          &lt;li&gt;算法：&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;在页面中增加&lt;strong&gt;修改位&lt;/strong&gt;，并在访问时进行相应修改&lt;/li&gt;
      &lt;li&gt;缺页时，修改页面标志位，以跳过有修改的页面&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://localhost:4000/blog/images/osm6.png&quot; alt=&quot;时钟页面置换算法的改进&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;最不常用算法 Least Frequently Used LFU 关键词：访问计数，计数定期右移 属于局部页面置换算法
    &lt;ul&gt;
      &lt;li&gt;思路：缺页时，置换访问次数最少的页面&lt;/li&gt;
      &lt;li&gt;实现：每个页面设置一个&lt;strong&gt;访问计数&lt;/strong&gt;，访问页面时&lt;strong&gt;访问计数&lt;/strong&gt;加一，缺页时置换计数最小的页面&lt;/li&gt;
      &lt;li&gt;特点：算法开销大；开始时频繁使用，但以后不使用的页面很难置换。
        &lt;ul&gt;
          &lt;li&gt;后者的&lt;strong&gt;改进&lt;/strong&gt;方法是：&lt;strong&gt;计数定期右移&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;与LRU的区别：LRU关注&lt;strong&gt;多久未访问&lt;/strong&gt;，LFU关注&lt;strong&gt;访问次数&lt;/strong&gt;
        &lt;h3 id=&quot;belady现象和局部置换算法比较&quot;&gt;BELADY现象和局部置换算法比较&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Belady现象：采用FIFO等算法时，可能出现&lt;strong&gt;分配的物理页面数增加&lt;/strong&gt;，缺页次数反而升高的现象
    &lt;h3 id=&quot;工作集置换算法-属于全局置换算法&quot;&gt;工作集置换算法 属于全局置换算法&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;思路&lt;/strong&gt;：局部置换算法没有考虑进程访存差异，比如有的进程需要的页数多，只是增加一页就可能大大降低缺页数；有的进程需要的页数少，缺少一页对缺页数也没有什么影响，然而因为局部置换算法不能进行进程之间的内存交换，所以无法针对这一问题进行优化，由此导出了全局置换算法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;要解决的问题&lt;/strong&gt;：进程在不同阶段的内存需求是变化的；分配给进程的内存也需要在不同阶段有所变化；全局置换算法需要确定分配给进程的物理页面数&lt;/li&gt;
  &lt;li&gt;工作集: 一个进程当前正在使用的逻辑页面集合，可表示为二元函数W(t, Δ)
    &lt;ul&gt;
      &lt;li&gt;t是当前的执行时刻&lt;/li&gt;
      &lt;li&gt;Δ称为工作集窗口（working-set window)，即一个定长的页面访问时间窗口&lt;/li&gt;
      &lt;li&gt;W(t, Δ)是指在当前时刻t前的Δ时间窗口中的所有访问页面所组成的集合&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;W(t, Δ)&lt;/td&gt;
              &lt;td&gt;是指工作集的大小，即页面数目&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;举例：假设页面访问顺序为2,6,1,5,7,7,7,7,5,1,6;t在1和6之间,Δ=10，那么W(t,Δ)={1,2,5,6,7}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;常驻集：在当前时刻，进程实际驻留在内存当中的页面集合
    &lt;ul&gt;
      &lt;li&gt;依据置换算法来确定常驻集&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缺页率与常驻集的关系：
    &lt;ul&gt;
      &lt;li&gt;常驻集⊇工作集时，缺页较少&lt;/li&gt;
      &lt;li&gt;工作集发生剧烈变动（过渡）时，缺页较多&lt;/li&gt;
      &lt;li&gt;进程常驻集大小达到一定数目后，缺页率也不会明显下降&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;算法
    &lt;ul&gt;
      &lt;li&gt;思路：&lt;strong&gt;换出不再工作集中的页面，时间点是在访存的时候&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;窗口大小τ：当前时刻前τ个内存访问的页引用是工作集，τ被称为窗口大小&lt;/li&gt;
      &lt;li&gt;实现方法：&lt;strong&gt;访存链表：维护窗口内访存页面链表。&lt;/strong&gt;访存时，换出不在工作集的页面；更新访存链表。缺页时，换入页面；更新访存链表
        &lt;h3 id=&quot;缺页率置换算法-关键词引用位-属于全局置换算法&quot;&gt;缺页率置换算法 关键词：引用位 属于全局置换算法&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;思想：通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内
    &lt;ul&gt;
      &lt;li&gt;若进程缺页率过高，则增加常驻集以分配更多的物理页面数&lt;/li&gt;
      &lt;li&gt;若进程缺页率过低，则减少常驻集以减少它的物理页面数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;访存时，设置引用位标志&lt;/li&gt;
  &lt;li&gt;缺页时，计算从上次缺页时间t&lt;sub&gt;last&lt;/sub&gt;到现在t&lt;sub&gt;current&lt;/sub&gt;的时间间隔
    &lt;ul&gt;
      &lt;li&gt;如果t&lt;sub&gt;current&lt;/sub&gt; - t&lt;sub&gt;last&lt;/sub&gt; &amp;gt; T，则置换所有在[t&lt;sub&gt;last&lt;/sub&gt;, t&lt;sub&gt;current&lt;/sub&gt;]时间内没有被引用的页&lt;/li&gt;
      &lt;li&gt;如果t&lt;sub&gt;current&lt;/sub&gt; - t&lt;sub&gt;last&lt;/sub&gt; ≤ T，则增加缺失页到常驻集中
        &lt;h3 id=&quot;抖动和负载控制&quot;&gt;抖动和负载控制&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;抖动问题 thrashing
    &lt;ul&gt;
      &lt;li&gt;进程物理页面太少，不能包含工作集&lt;/li&gt;
      &lt;li&gt;造成大量缺页，频繁置换&lt;/li&gt;
      &lt;li&gt;进程运行速度变慢&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;产生抖动的原因：随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升&lt;/li&gt;
  &lt;li&gt;操作系统需在并发水平和缺页率之间达到一个平衡
    &lt;ul&gt;
      &lt;li&gt;选择一个适当的进程数目和进程需要的物理页面数
###文件系统&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件系统是操作系统中管理持久性数据的子系统，提供数据存储和访问功能
    &lt;ul&gt;
      &lt;li&gt;组织、检索、读写访问数据&lt;/li&gt;
      &lt;li&gt;大多数计算机系统都有文件系统&lt;/li&gt;
      &lt;li&gt;Google也是一个文件系统&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件是具有符号名，由字节序列构成的数据项集合
    &lt;ul&gt;
      &lt;li&gt;文件系统的基本数据单位&lt;/li&gt;
      &lt;li&gt;文件名是文件的标识符号&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件系统的功能
    &lt;ul&gt;
      &lt;li&gt;分配文件磁盘空间
        &lt;ul&gt;
          &lt;li&gt;管理文件块（位置和顺序）&lt;/li&gt;
          &lt;li&gt;管理空闲空间（位置）&lt;/li&gt;
          &lt;li&gt;分配算法（策略）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;管理文件集合
        &lt;ul&gt;
          &lt;li&gt;定位：文件及其内容&lt;/li&gt;
          &lt;li&gt;命名：通过名字找到文件&lt;/li&gt;
          &lt;li&gt;文件系统结构：文件组织方式&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;数据可靠和安全
        &lt;ul&gt;
          &lt;li&gt;安全：多层次保护数据安全&lt;/li&gt;
          &lt;li&gt;可靠&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;持久保存文件&lt;/li&gt;
      &lt;li&gt;避免系统崩溃、媒体错误、攻击等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件属性：名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间…&lt;/li&gt;
  &lt;li&gt;文件头：文件系统元数据中的文件信息
    &lt;ul&gt;
      &lt;li&gt;文件属性&lt;/li&gt;
      &lt;li&gt;文件存储位置和顺序
        &lt;h3 id=&quot;文件描述符&quot;&gt;文件描述符&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;打开的文件在内存中维护的相关信息&lt;/li&gt;
  &lt;li&gt;文件访问模式：进程访问文件数据前必须打开“文件”&lt;/li&gt;
  &lt;li&gt;内核跟踪进程打开的所有文件
    &lt;ul&gt;
      &lt;li&gt;操作系统为&lt;strong&gt;每个进程维护一个打开文件表&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;文件描述符是打开文件的标识&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;操作系统在打开文件表中维护的打开文件状态和信息
    &lt;ul&gt;
      &lt;li&gt;文件指针&lt;/li&gt;
      &lt;li&gt;文件打开计数&lt;/li&gt;
      &lt;li&gt;文件的磁盘位置&lt;/li&gt;
      &lt;li&gt;访问权限&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件的用户视图和系统试图
    &lt;ul&gt;
      &lt;li&gt;文件的用户视图：持久的数据结构&lt;/li&gt;
      &lt;li&gt;系统访问结构：字节序列的集合（UNIX）；系统不关心存储在硬盘上的数据结构&lt;/li&gt;
      &lt;li&gt;操作系统的文件视图：
        &lt;ul&gt;
          &lt;li&gt;数据块的集合&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;数据块&lt;/strong&gt;是逻辑存储单元，而&lt;strong&gt;扇区&lt;/strong&gt;是物理存储单元&lt;/li&gt;
          &lt;li&gt;块大小≠扇区大小&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;进程读文件
    &lt;ul&gt;
      &lt;li&gt;获取字节所在的数据块&lt;/li&gt;
      &lt;li&gt;返回字节内对应部分&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;进程写文件
    &lt;ul&gt;
      &lt;li&gt;获取数据块&lt;/li&gt;
      &lt;li&gt;修改数据块中对应部分&lt;/li&gt;
      &lt;li&gt;写回数据块&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;文件系统中的基本操作单位是数据块&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;例如，getc()和putc()即使每次只访问1字节的数据，也需要缓存目标数据4096字节&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;访问模式
    &lt;ul&gt;
      &lt;li&gt;操作系统需要了解进程如何访问文件&lt;/li&gt;
      &lt;li&gt;顺序访问：按字节一次读取；大多数的文件访问都是顺序访问&lt;/li&gt;
      &lt;li&gt;随机访问：从中间读写；不常用，但仍然重要，例如，虚拟内存中把内存页存储在文件&lt;/li&gt;
      &lt;li&gt;索引访问：依据数据特征索引
        &lt;ul&gt;
          &lt;li&gt;通常操作系统不完整提供索引访问&lt;/li&gt;
          &lt;li&gt;数据块是建立在索引内容的磁盘访问上&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件内部结构 操作系统对文本文档和可执行文件提供某种程度的识别
    &lt;ul&gt;
      &lt;li&gt;无结构：单词，字节序列&lt;/li&gt;
      &lt;li&gt;简单记录结构：分列，固定长度，可变长度&lt;/li&gt;
      &lt;li&gt;复杂结构：格式化的文档，可执行文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件共享和访问控制
    &lt;ul&gt;
      &lt;li&gt;多用户中的文件共享是很必要的&lt;/li&gt;
      &lt;li&gt;访问控制：每个用户能够获得哪些文件的哪些访问权限；读，写，执行，删除，列表等&lt;/li&gt;
      &lt;li&gt;文件访问控制列表ACL：&amp;lt;文件实体，权限&amp;gt;&lt;/li&gt;
      &lt;li&gt;Unix模式
        &lt;ul&gt;
          &lt;li&gt;
            &lt;table&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td&gt;&amp;lt;用户&lt;/td&gt;
                  &lt;td&gt;组&lt;/td&gt;
                  &lt;td&gt;所有人，读&lt;/td&gt;
                  &lt;td&gt;写&lt;/td&gt;
                  &lt;td&gt;可执行&amp;gt;；&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/li&gt;
          &lt;li&gt;用户识别ID：识别用户，表面每个用户所允许的权限及保护模式&lt;/li&gt;
          &lt;li&gt;组标识ID：允许用户组成组，并指定了组访问权限&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;语义一致性
    &lt;ul&gt;
      &lt;li&gt;规定多进程如何同时访问共享文件
        &lt;ul&gt;
          &lt;li&gt;与同步算法相似&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Unix文件系统UFS语义
        &lt;ul&gt;
          &lt;li&gt;打开文件的写入内容立即对同一文件的其他用户可见&lt;/li&gt;
          &lt;li&gt;共享文件指针允许多用户同时读取和写入文件&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;会话语义：写入内容只有当文件关闭时可见&lt;/li&gt;
      &lt;li&gt;读写锁：一些操作系统和文件系统提供该功能
        &lt;h3 id=&quot;目录文件别名和文件系统种类&quot;&gt;目录、文件别名和文件系统种类&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分层文件系统
    &lt;ul&gt;
      &lt;li&gt;文件以&lt;strong&gt;目录&lt;/strong&gt;的方式组织起来&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;目录是一类特殊的文件：目录的内容是文件索引表&amp;lt;文件名，指向文件的指针&amp;gt;&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;目录和文件的树形结构：早期的文件系统是扁平的（只有一层目录）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;目录的操作
    &lt;ul&gt;
      &lt;li&gt;搜索文件；创建文件；删除文件；列目录；重命名文件；遍历路径&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;操作系统应该只允许内核修改目录
    &lt;ul&gt;
      &lt;li&gt;确保映射的完整性&lt;/li&gt;
      &lt;li&gt;应用程序通过系统调用访问目录&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;目录实现：线性列表，哈希表&lt;/li&gt;
  &lt;li&gt;文件别名：硬链接：多个文件项指向一个文件，文件系统会维护一个引用计数，只要有文件指向这个区块，它就不会从硬盘上消失，也就是说如果有多个文件指向某个区块，除非把文件全删除了，否则该区块不会消失；软链接：以“快捷方式”指向其他文件，通过存储真实文件的逻辑名称来实现，类似于windows系统中的链接，一旦把文件删除了，点击链接时就会找不到文件，如果把删除的文件再放回来，点击文件时就又能找到了&lt;/li&gt;
  &lt;li&gt;文件目录中的循环：只允许到文件的链接，不允许在子目录的链接；增加链接时，用循环检测算法确定是否合理；限制路径可遍历文件目录的数量&lt;/li&gt;
  &lt;li&gt;名字解析（路径遍历）
    &lt;ul&gt;
      &lt;li&gt;名字解析：把逻辑名字转换为物理资源（如文件）&lt;/li&gt;
      &lt;li&gt;当前工作目录（PWD）
        &lt;ul&gt;
          &lt;li&gt;每个进程都会指向一个文件目录用于解析文件名&lt;/li&gt;
          &lt;li&gt;允许用户指定相对路径来代替绝对路径&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;文件系统挂载&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;文件系统需要先挂载才能被访问&lt;/li&gt;
      &lt;li&gt;未挂载的文件系统被挂载在挂载点上&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件系统种类
    &lt;ul&gt;
      &lt;li&gt;磁盘文件系统
        &lt;ul&gt;
          &lt;li&gt;文件存储在数据存储设备上，如磁盘&lt;/li&gt;
          &lt;li&gt;例如：FAT，NTFS，ext2/3，ISO9660等&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;数据库文件系统
        &lt;ul&gt;
          &lt;li&gt;文件特征是可被寻址（辨识）的&lt;/li&gt;
          &lt;li&gt;例如：WinFS&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;日志文件系统：记录文件系统的修改／事件&lt;/li&gt;
      &lt;li&gt;网络／分布式文件系统：NFS，SMB，AFS，GFS
        &lt;ul&gt;
          &lt;li&gt;文件可以通过网络被共享&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;文件位于远程服务器&lt;/li&gt;
      &lt;li&gt;客户端远程挂载服务器文件系统&lt;/li&gt;
      &lt;li&gt;标准系统文件访问被转换成远程访问&lt;/li&gt;
      &lt;li&gt;标准文件共享协议：NFS for Unix, CIFS for Windows
    - 分布式文件系统的挑战：客户端和客户端上的用户辨别起来很复杂
    - 特殊／虚拟分级系统
        &lt;h3 id=&quot;虚拟文件系统-vfs&quot;&gt;虚拟文件系统 VFS&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分层结构：虚拟（逻辑）文件系统 VFS，Virtual File System，特定文件系统模块(FAT,NTFS之类)&lt;/li&gt;
  &lt;li&gt;文件系统基本数据机构
    &lt;ul&gt;
      &lt;li&gt;文件卷控制块（Unix: “superblock”）
        &lt;ul&gt;
          &lt;li&gt;每个文件系统一个&lt;/li&gt;
          &lt;li&gt;文件系统详细信息&lt;/li&gt;
          &lt;li&gt;块，块大小，空余块，计数／指针等&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;文件控制块（Unix:”vnode” or “inode”)
        &lt;ul&gt;
          &lt;li&gt;每个文件一个&lt;/li&gt;
          &lt;li&gt;文件详细信息&lt;/li&gt;
          &lt;li&gt;访问权限，拥有者，大小，数据块位置等&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;目录项（Linux:”dentry”)
        &lt;ul&gt;
          &lt;li&gt;每个目录项一个（对应着目录或文件）&lt;/li&gt;
          &lt;li&gt;将目录项数据结构及树形布局编码成树形数据结构&lt;/li&gt;
          &lt;li&gt;指向文件控制块，父目录，子目录等&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件系统数据结构
    &lt;ul&gt;
      &lt;li&gt;卷控制块 每个文件系统一个&lt;/li&gt;
      &lt;li&gt;文件控制块 每个文件一个&lt;/li&gt;
      &lt;li&gt;目录节点 每个目录项一个&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;持久存储在外存中：存储设备的数据块中&lt;/li&gt;
  &lt;li&gt;当需要时加载进内存
    &lt;ul&gt;
      &lt;li&gt;卷控制模块：当文件系统挂载时进入内存&lt;/li&gt;
      &lt;li&gt;文件控制块：当文件被访问时进入每次&lt;/li&gt;
      &lt;li&gt;目录节点：在遍历一个文件路径时进入内存
        &lt;h3 id=&quot;文件缓存和打开文件&quot;&gt;文件缓存和打开文件&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;http://localhost:4000/blog/images/osm7.png&quot; alt=&quot;多种磁盘缓冲位置&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;操作系统讨论的是在内存中的&lt;strong&gt;数据块缓存&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;数据块缓存
    &lt;ul&gt;
      &lt;li&gt;数据块按需读入内存
        &lt;ul&gt;
          &lt;li&gt;提供read()操作&lt;/li&gt;
          &lt;li&gt;预读：预先读取后面的数据块&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;数据块使用后被缓存
        &lt;ul&gt;
          &lt;li&gt;假设数据将会再次用到&lt;/li&gt;
          &lt;li&gt;写操作可能被缓存和延迟写入&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;两种数据块缓存方式
        &lt;ul&gt;
          &lt;li&gt;数据块缓存&lt;/li&gt;
          &lt;li&gt;页缓存：统一缓存数据块和内存页&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;//TODO&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">并发是指两个或多个事件在同一时间间隔内发生。 注意同一时间间隔（并发）和同一时刻（并行）的区别。 举例：在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每一时刻，单处理机环境下实际仅能有一道程序执行，故微观上这些程序还是在分时地交替执行。 计算机开机后，操作系统最终被加载到RAM 我们把一段时间内只允许一个进程访问的资源称为临界资源或独占资源。 批处理操作系统、分时操作系统和实时操作系统各有什么特点？ 批处理操作系统的用户脱机使用计算机，作业是成批处理的，系统内多道程序并发执行，交互能力差 分时操作系统可以让多个用户同时使用计算机，人机交互性较强，具有每个用户独立使用计算机的独占性，系统响应及时。 实时操作系统能对控制对象作出及时反应，可靠性高，响应及时，但是资源利用率低。 甘特图画出逻辑控制流Logical Control Flow图 访管指令 中断处理和子程序调用都需要压栈以保护现场，中断处理一定会保存而子程序调用不需要保存其内容的是程序状态字寄存器PSW 程序状态字PSW有一系列标志位，典型的有IF（Interrupt Flag）。在一些计算机结构是状态寄存器SR和程序计数器PC的结合体。 异常可以分为4类，中断(Interrupt)，陷阱(Trap)，故障(Fault)，终止(Abort)。 典型的陷阱有read、fork、execve、exit，处理器提供了一条特殊的“syscall n”指令用以调用它们；典型的故障有缺页异常；典型的终止有DRAM或SRAM损坏时发生的奇偶错误 对于x86-64系统而言，有高达256种不同的异常类型。其中0~32的号码对应Intel架构师定义的异常，因此对任何x86-64系统都是一样的；32~255的号码对应的是操作系统定义的中断和陷阱 在x86-64系统中，Linux系统调用的参数通过通用寄存器而不是栈来传递。按照惯例，寄存器%rax包含系统调用号，寄存器%rdi、%rsi、%rdx、%r10、%r8、%r9包含参数，显然最多可有6个参数。当系统调用返回时%rax包含返回值，-4095到-1之间的负数表明发生了错误，对应于负的errno 中断隐指令：CPU响应中断之后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，被称之为中断隐指令。中断隐指令并不指指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种不允许、也不可能为用户使用的特殊指令。其所完成的操作主要有： 保存断点 关中断 引出中断服务程序 对于私有地址空间而言，代码段总是从0x400000开始，0~0x400000保留给内核 Linux提高了一种聪明的机制，叫做/proc文件系统，它允许用户模式进程访问内核数据结构的内容。你可以用它来找出系统属性，比如CPU类型(/proc/cpuinfo)，或者某个特殊的进程使用的内存段（/proc//maps)。2.6版本的的Linux内核引入**/sys**文件系统，提供关于系统总线和设备的额外信息。 fork函数只被调用一次，却会返回两次：一次在父进程中，一次在子进程中；返回给父进程子进程的pid，返回给子进程0。 当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收(reaped)。一个终止了但还未被回收的进程称为僵死进程（zombie）。 如果一个父进程终止了，内核会安排init进程称为它的孤儿进程的养父。init进程的PID为1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。 一个进程可以通过调用waitpid函数来等待它的子进程终止或者停止。waitpid挂起调用进程的执行，直到它的等待集合（wait set)中的一个子进程终止。对于第一个参数pid而言，若针对特定子进程A，则其为A的pid；若针对全体子进程，则其为-1。第二个参数用于检查已回收子进程的退出状态。第三个参数用于修改waitpid的默认行为。第二、三个参数较为复杂，不赘述。 ```c #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/wait.h&amp;gt;</summary></entry><entry><title type="html">北京大学操作系统笔记</title><link href="http://localhost:4000/blog/operating/system/2017/10/01/os.html" rel="alternate" type="text/html" title="北京大学操作系统笔记" /><published>2017-10-01T00:00:00+08:00</published><updated>2017-10-01T00:00:00+08:00</updated><id>http://localhost:4000/blog/operating/system/2017/10/01/os</id><content type="html" xml:base="http://localhost:4000/blog/operating/system/2017/10/01/os.html">&lt;h1 id=&quot;1操作系统概述&quot;&gt;1.操作系统概述&lt;/h1&gt;
&lt;p&gt;操作系统主要特征：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;并发，共享，虚拟，随机&lt;/li&gt;
  &lt;li&gt;并发：同时处理多个活动的能力
  活动切换，保护，相互依赖的活动间的同步&lt;/li&gt;
  &lt;li&gt;共享：共享有限的系统资源&lt;br /&gt;
  互斥共享&lt;br /&gt;
  同时共享&lt;/li&gt;
  &lt;li&gt;虚拟：一个物理实体映射为若干个逻辑实体&lt;/li&gt;
  &lt;li&gt;随机：对以不可预测的次序发生的事件进行相应并处理&lt;/li&gt;
  &lt;li&gt;SPOOLING系统（技术）
    &lt;ul&gt;
      &lt;li&gt;批处理系统的实现通常采用的技术&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分时操作系统&lt;/li&gt;
  &lt;li&gt;实时操作系统&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;2操作系统运行环境&quot;&gt;2.操作系统运行环境&lt;/h1&gt;

&lt;h2 id=&quot;处理器状态&quot;&gt;处理器状态&lt;/h2&gt;

&lt;p&gt;两类寄存器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;用户可见寄存器：
    &lt;ul&gt;
      &lt;li&gt;高级语言编译器通过优化算法分配之，以减少程序访问内存次数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;控制和状态寄存器：
    &lt;ul&gt;
      &lt;li&gt;用于控制处理器的操作，通常由操作系统代码使用&lt;/li&gt;
      &lt;li&gt;常见的有&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;IR&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;PSW&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;PSW：程序状态字，记录处理器的运行状态如条件码、模式、控制位等信息&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;操作系统的需求-保护&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从操作系统的特征考虑，并发、共享&lt;/li&gt;
  &lt;li&gt;硬件提供的机制
    &lt;ul&gt;
      &lt;li&gt;处理器具有特权级别，能在不同的特权级运行的不同指令集合&lt;/li&gt;
      &lt;li&gt;硬件机制可将OS与用户程序隔离&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;程序状态字寄存器PSW专门设置一位，根据运行程序&lt;code class=&quot;highlighter-rouge&quot;&gt;对资源和指令的使用权限&lt;/code&gt;而设置不同的CPU状态&lt;/p&gt;

&lt;p&gt;操作系统需要两种CPU状态&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;内核态（kernel mode）：运行操作系统程序
    &lt;ul&gt;
      &lt;li&gt;可使用全部指令&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用户态（user mode）：运行用户程序
    &lt;ul&gt;
      &lt;li&gt;只可使用非特权指令&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;特权（privilege）指令：只能由操作系统使用，用户程序不能使用的指令
非特权指令：用户程序可以使用的指令&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/blog/images/os0.png&quot; alt=&quot;privilege&quot; /&gt;&lt;/p&gt;

&lt;p&gt;x86支持4个处理器特权级别&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从R0到R3,特权级别由高到低&lt;/li&gt;
  &lt;li&gt;R0相当于内核态，R3相当于用户态，R1、R2介于两者之间&lt;/li&gt;
  &lt;li&gt;大多数基于x86处理器的操作系统&lt;code class=&quot;highlighter-rouge&quot;&gt;只用了R0和R3两个特权级别&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用户态进入内核态的唯一途径&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;中断/异常/陷入机制&lt;/li&gt;
  &lt;li&gt;陷入指令：提供给用户程序的接口，用于调用操作系统的功能（服务）
    &lt;ul&gt;
      &lt;li&gt;例如：int，trap，syscall，sysenter/sysexit&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内核态进入用户态&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;设置程序状态字PSW&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;中断与异常机制介绍&quot;&gt;中断与异常机制介绍&lt;/h2&gt;

&lt;p&gt;中断举例：I/O中断，时钟中断，硬件中断&lt;/p&gt;

&lt;p&gt;异常举例：系统调用，页故障/页错误，保护性异常，断点指令，其他程序性异常&lt;/p&gt;

&lt;h2 id=&quot;中断与异常机制的工作原理&quot;&gt;中断与异常机制的工作原理&lt;/h2&gt;

&lt;p&gt;若有中断，中断硬件将该中断触发器内容按规定编码送入PSW的相应位，称为&lt;code class=&quot;highlighter-rouge&quot;&gt;中断码&lt;/code&gt;，通过查&lt;code class=&quot;highlighter-rouge&quot;&gt;中断向量表&lt;/code&gt;引出中断处理程序&lt;/p&gt;

&lt;h2 id=&quot;x86处理器对中断异常的支持&quot;&gt;x86处理器对中断/异常的支持&lt;/h2&gt;

&lt;p&gt;中断控制器（PIC）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;负责将硬件的中断信号转换为中断向量，并引发CPU中断&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;中断向量&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;存放程序状态字和中断处理程序入口地址的内存单元&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实模式（中断向量表 Interrupt Vector）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;存放中断服务程序的入口地址 = 段地址左移4位+偏移地址&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;保护模式中断描述符表-interrupt-descriptor-table&quot;&gt;保护模式（中断描述符表 Interrupt Descriptor Table）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;采用门描述符数据结构表示中断向量&lt;/li&gt;
  &lt;li&gt;任务门&lt;/li&gt;
  &lt;li&gt;中断门：通过门后系统会自动禁止中断&lt;/li&gt;
  &lt;li&gt;陷阱门：通过门后系统不会禁止中断&lt;/li&gt;
  &lt;li&gt;调用门&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;通过IDTR和向量i找到IDT，通过中断描述符的段选择符，结合GDTR，找到GDT（全局描述符表）的段描述符，将其中的段基址与IDT中的偏移量相结合就得到了中断服务程序的入口地址&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;检查特权级是否发生了变化，如果是，则进行堆栈切换&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;压栈&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;如果是中断，清IF位&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;通过入口地址，执行第一条指令&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;系统调用机制system-call&quot;&gt;系统调用机制(SYSTEM CALL)&lt;/h2&gt;

&lt;p&gt;系统调用是操作系统提供给用户的唯一接口&lt;/p&gt;

&lt;p&gt;使CPU状态从用户态陷入内核态&lt;/p&gt;

&lt;p&gt;每个操作系统提供几百种系统调用&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;进程控制，进程通信，文件使用，目录操作，设备管理，信息维护&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;系统调用，库函数，API，内核函数&lt;/p&gt;

&lt;p&gt;系统调用机制的设计&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;中断/异常机制： 支持系统调用服务的实现&lt;/li&gt;
  &lt;li&gt;选择一条特殊指令（陷入指令）： 引发异常，完成用户态到内核态的切换&lt;/li&gt;
  &lt;li&gt;系统调用号和参数： 每个系统调用都事先给定一个编号（功能号）&lt;/li&gt;
  &lt;li&gt;系统调用表： 存放系统调用服务例程的入口地址&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;传递参数&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;由陷入指令自带参数&lt;/li&gt;
  &lt;li&gt;通过通用寄存器传递参数&lt;/li&gt;
  &lt;li&gt;在内存中开辟专用堆栈区&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;;write()函数
movl $4,%eax
int $0x80
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;;exit函数
movl $1,%eax
int $0x80
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;例子linux系统调用实现&quot;&gt;例子：LINUX系统调用实现&lt;/h2&gt;
&lt;p&gt;中断发生后OS底层工作步骤&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;硬件压栈：程序计数器等&lt;/li&gt;
  &lt;li&gt;硬件从中断向量装入新的程序计数器等&lt;/li&gt;
  &lt;li&gt;汇编语言过程保存寄存器值&lt;/li&gt;
  &lt;li&gt;汇编语言过程设置新的堆栈&lt;/li&gt;
  &lt;li&gt;C语言中断服务程序运行&lt;/li&gt;
  &lt;li&gt;进程调度程序决定下一个将运行的进程&lt;/li&gt;
  &lt;li&gt;C语言过程返回至汇编代码&lt;/li&gt;
  &lt;li&gt;汇编语言过程开始运行新的当前进程&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;3进程线程模型&quot;&gt;3.进程线程模型&lt;/h1&gt;

&lt;h2 id=&quot;进程的基本概念&quot;&gt;进程的基本概念&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;多道程序设计（MULTIPROGRAMMING）&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;允许多个程序同时进入内存并运行，其目的是为了提高系统效率&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;操作系统将CPU调度给需要的进程&lt;/p&gt;

&lt;h3 id=&quot;进程控制块pcb&quot;&gt;进程控制块（PCB）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Process Control Block&lt;/li&gt;
  &lt;li&gt;又称&lt;code class=&quot;highlighter-rouge&quot;&gt;进程描述符&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;进程属性&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;操作系统用于管理控制进程的一个专门数据结构&lt;/li&gt;
  &lt;li&gt;进程与PCB一一对应&lt;/li&gt;
  &lt;li&gt;进程表：所有进程PCB的集合&lt;/li&gt;
  &lt;li&gt;Linux：task_struct; Windows:EPROCESS、KPROCESS、PEB&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;进程描述信息
    &lt;ul&gt;
      &lt;li&gt;进程标识符（process id），唯一，通常是一个整数&lt;/li&gt;
      &lt;li&gt;用户标识符（user id）&lt;/li&gt;
      &lt;li&gt;进程名&lt;/li&gt;
      &lt;li&gt;进程组关系&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;进程控制信息
    &lt;ul&gt;
      &lt;li&gt;当前状态&lt;/li&gt;
      &lt;li&gt;优先级&lt;/li&gt;
      &lt;li&gt;代码执行入口地址&lt;/li&gt;
      &lt;li&gt;程序的磁盘地址&lt;/li&gt;
      &lt;li&gt;运行统计信息&lt;/li&gt;
      &lt;li&gt;进程间同步和通信&lt;/li&gt;
      &lt;li&gt;进程的队列指针&lt;/li&gt;
      &lt;li&gt;进程的消息队列指针&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;所拥有的资源和使用情况
    &lt;ul&gt;
      &lt;li&gt;虚拟地址空间的状况&lt;/li&gt;
      &lt;li&gt;打开文件列表&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CPU现场信息
    &lt;ul&gt;
      &lt;li&gt;寄存器值&lt;/li&gt;
      &lt;li&gt;指向该进程页表的指针&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;进程的状态和状态转换&quot;&gt;进程的状态和状态转换&lt;/h2&gt;

&lt;p&gt;三种基本状态&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;运行态： 占有CPU，并在CPU上运行&lt;/li&gt;
  &lt;li&gt;就绪态： 已经具备运行条件，但无空闲CPU，而暂时不能运行&lt;/li&gt;
  &lt;li&gt;等待态： 也叫阻塞态、封锁态、睡眠态，因等待某一时间而暂时不能运行&lt;/li&gt;
  &lt;li&gt;创建： 已完成创建，但尚未同意执行该进程&lt;/li&gt;
  &lt;li&gt;终止： 终止进程，资源回收&lt;/li&gt;
  &lt;li&gt;挂起：用于调节负载，其进程映像交换到磁盘上&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;LINUX状态示意图
&lt;img src=&quot;http://localhost:4000/blog/images/os1.png&quot; alt=&quot;LINUX&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进程队列&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;伴随着进程的改变，其PCB从一个队列进入另一个队列&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;进程控制&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;进程控制&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;进程控制操作完成进程各状态之间的转换，由具有特定功能的&lt;code class=&quot;highlighter-rouge&quot;&gt;原语&lt;/code&gt;完成&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;进程创建原语，进程撤销原语，阻塞原语，唤醒原语，挂起原语，激活原语，改变进程优先级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原语（primitive）又叫原子操作（atomic）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;完成特定功能的一段程序，具有不可分割或不可中断性&lt;/li&gt;
  &lt;li&gt;即原语的执行必须是连续的，在执行过程中不允许被中断&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;进程的创建
    &lt;ul&gt;
      &lt;li&gt;为新进程分配一个唯一标识以及PCB&lt;/li&gt;
      &lt;li&gt;为进程分配地址空间&lt;/li&gt;
      &lt;li&gt;初始化进程控制块&lt;/li&gt;
      &lt;li&gt;设置相应的队列指针&lt;/li&gt;
      &lt;li&gt;UNIX: fork/exec; WINDOWS: CreateProcess&lt;/li&gt;
      &lt;li&gt;exec: 通过用一段新的程序代码覆盖原来的地址空间，实现进程执行代码的转换&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;进程的撤销
    &lt;ul&gt;
      &lt;li&gt;结束进程&lt;/li&gt;
      &lt;li&gt;收回进程所占有的资源
        &lt;ul&gt;
          &lt;li&gt;关闭打开的文件、断开网路连接、回收分配的内存&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;撤销该进程的PCB&lt;/li&gt;
      &lt;li&gt;UNIX: exit; WINDOWS: TerminateProcess&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;进程的阻塞
    &lt;ul&gt;
      &lt;li&gt;等待某一事件发生，在其尚未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态&lt;/li&gt;
      &lt;li&gt;UNIX: wait; WINDOWS: WaitForSingleObject&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;fork的实现&quot;&gt;Fork的实现&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;为子进程分配一个空闲的进程描述符
    &lt;ul&gt;
      &lt;li&gt;proc结构&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分配给子进程唯一标识pid&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;以一次一页的方式复制父进程地址空间&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;Linux采用了写时复制技术COW加快创建进程Copy-On—Write&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;从父进程处继承共享资源，如打开的文件和当前工作目录等&lt;/li&gt;
  &lt;li&gt;将子进程的状态设为就绪，插入到就绪队列&lt;/li&gt;
  &lt;li&gt;对子进程返回标识符0&lt;/li&gt;
  &lt;li&gt;向父进程返回子进程的pid&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/blog/images/os2.png&quot; alt=&quot;LINUX&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;关于进程相关概念的讨论&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;关于进程相关概念的讨论&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;进程的分类&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;系统进程,用户进程；前台进程，后台进程；CPU密集型进程，I/O密集型进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进程层次结构&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;UNIX：进程家族树；Windows：地位相同&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;进程映像（IMAGE）&lt;/code&gt;： 对进程执行活动全过程的静态描述&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;上下文切换&lt;/code&gt;： 将CPU硬件从一个进程换到另一个进程的过程称为上下文切换&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;进程不运行时，寄存器的值保存于PCB，要允许新进程时，PCB的相关值送到对应的寄存器&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;线程的引入&quot;&gt;线程的引入&lt;/h2&gt;

&lt;p&gt;为什么在进程中再派生出线程&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;应用的考虑&lt;/li&gt;
  &lt;li&gt;开销的考虑&lt;/li&gt;
  &lt;li&gt;性能的考虑&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/blog/images/os3.png&quot; alt=&quot;THREAD&quot; /&gt;&lt;/p&gt;

&lt;p&gt;线程：进程中的一个运行实体，是CPU的调度单位，有时将线程称为&lt;code class=&quot;highlighter-rouge&quot;&gt;轻量级进程&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;由标识符ID&lt;/li&gt;
  &lt;li&gt;有状态及状态转换 -&amp;gt; 需要提供一些操作&lt;/li&gt;
  &lt;li&gt;不运行时需要保存上下文&lt;/li&gt;
  &lt;li&gt;有自己的栈和栈指针&lt;/li&gt;
  &lt;li&gt;共享所在进程的地址空间和其他资源&lt;/li&gt;
  &lt;li&gt;可以创建、撤销另一个线程&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;线程机制的实现&quot;&gt;线程机制的实现&lt;/h2&gt;

&lt;p&gt;用户级线程，核心(Kernel)级线程，混合-两者结合方法&lt;/p&gt;

&lt;p&gt;用户级线程小结&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;优点：
    &lt;ul&gt;
      &lt;li&gt;线程切换快&lt;/li&gt;
      &lt;li&gt;调度算法是应用程序特定的&lt;/li&gt;
      &lt;li&gt;用户级线程可运行在任何OS上&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缺点：
    &lt;ul&gt;
      &lt;li&gt;内核只能讲CPU分配给进程，同一进程中的两个线程不能同时运行于两个处理器上&lt;/li&gt;
      &lt;li&gt;大多数系统调用是阻塞的，因此由于内核阻塞进程，进程中的所有线程也被阻塞
        &lt;ul&gt;
          &lt;li&gt;可以将系统调用改为非阻塞的&lt;/li&gt;
          &lt;li&gt;Jackeing/Wrapper&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可再入程序&lt;/p&gt;

&lt;h1 id=&quot;4处理器调度&quot;&gt;4.处理器调度&lt;/h1&gt;

&lt;h2 id=&quot;处理器调度的相关概念&quot;&gt;处理器调度的相关概念&lt;/h2&gt;

&lt;p&gt;CPU调度&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;其任务是控制、协调进程对CPU的竞争&lt;/li&gt;
  &lt;li&gt;即按一定的调度算法从就绪队列中选择一个进程，把CPU的使用权交给被选中的进程&lt;/li&gt;
  &lt;li&gt;如果没有就绪进程，系统会安排一个系统空闲进程或idle进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;调度算法、调度时机、调度过程&lt;/p&gt;

&lt;p&gt;调度时机（内核对中断/异常/系统调用处理后返回用户态时）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;进程正常终止或由于某种错误而终止&lt;/li&gt;
  &lt;li&gt;新进程创建或一个等待进程变就绪&lt;/li&gt;
  &lt;li&gt;当一个进程从运行态变阻塞态&lt;/li&gt;
  &lt;li&gt;当一个进程从运行态变就绪态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进程切换&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;切换&lt;code class=&quot;highlighter-rouge&quot;&gt;全局页目录&lt;/code&gt;以加载一个新的地址空间&lt;/li&gt;
  &lt;li&gt;切换内核栈和硬件上下文&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上下文切换开销（COST）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;直接开销：保存和恢复寄存器、切换地址空间&lt;/li&gt;
  &lt;li&gt;间接开销：高速缓存、缓冲区缓存、TLB失效&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;调度算法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;用户角度和系统角度考虑的问题是不一样的，设计算法时要在各种因素中做一个权衡&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;调度算法衡量指标&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;吞吐量 Throughout
    &lt;ul&gt;
      &lt;li&gt;每单位时间完成的进程数目&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;周转时间 TT（Turnaround Time）
    &lt;ul&gt;
      &lt;li&gt;每个进程从提出请求到运行完成的时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;响应时间RT（Response Time）
    &lt;ul&gt;
      &lt;li&gt;从提出请求到第一次回应的时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CPU利用率（CPU Utilization）
    &lt;ul&gt;
      &lt;li&gt;CPU做有效工作的时间比例&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;等待时间（Waiting Time）
    &lt;ul&gt;
      &lt;li&gt;每个进程在就绪队列（ready queue）中等待的时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;设计调度算法时要考虑的几个问题&quot;&gt;设计调度算法时要考虑的几个问题&lt;/h2&gt;

&lt;p&gt;进程优先级（数）&lt;/p&gt;

&lt;p&gt;优先级队列&lt;/p&gt;

&lt;p&gt;抢占与非抢占&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可抢占式Preempive(可剥夺式)
    &lt;ul&gt;
      &lt;li&gt;可抢占优先级低进程的CPU&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;非可抢占式
    &lt;ul&gt;
      &lt;li&gt;与上相反&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;时间片 Time Slice或quantum&lt;/p&gt;

&lt;h2 id=&quot;批处理系统的调度算法&quot;&gt;批处理系统的调度算法&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;先来先服务（FCFS-First Come First Serve）
    &lt;ul&gt;
      &lt;li&gt;谁先就绪，谁先上CPU&lt;/li&gt;
      &lt;li&gt;非抢占式&lt;/li&gt;
      &lt;li&gt;短时进程在长时进程后面，用户体验不够友好&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;最短作业优先（SJF-Shortest Job First）
    &lt;ul&gt;
      &lt;li&gt;具有最短完成时间的进程优先完成&lt;/li&gt;
      &lt;li&gt;非抢占式&lt;/li&gt;
      &lt;li&gt;源源不断的短任务到来，可能使长的任务长时间得不到运行，产生&lt;code class=&quot;highlighter-rouge&quot;&gt;饥饿现象&lt;/code&gt;（Starvation）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;最短剩余时间优先（SRTN-Shortest Remaining Time Next）
    &lt;ul&gt;
      &lt;li&gt;若新就绪的进程比当前进程具有更短的完成，系统抢占当前进程，选择新就绪的进程执行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;最高响应比优先(HRRN-Highest Response Ratio Next)
    &lt;ul&gt;
      &lt;li&gt;调度时，首先计算每个计算的响应比R;之后总是选择R最高的进程执行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;交互式系统的调度算法&quot;&gt;交互式系统的调度算法&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;轮转调度（RR-Round Robin）
    &lt;ul&gt;
      &lt;li&gt;时间片轮转
        &lt;ul&gt;
          &lt;li&gt;每个进程分配一个时间片，周期性切换&lt;/li&gt;
          &lt;li&gt;由于进程切换，时间片轮转算法要花费较高的开销&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;虚拟轮转
        &lt;ul&gt;
          &lt;li&gt;因为I/O进程总是会进入阻塞状态，从而用不完它的时间片，等到事件完成，它会进入就绪队列的最尾端；而CPU进程总能充分的利用它的时间片。这就造成了不公平。&lt;/li&gt;
          &lt;li&gt;所以单独为I/O进程设置&lt;code class=&quot;highlighter-rouge&quot;&gt;辅助队列&lt;/code&gt;，CPU优先处理I/O进程，处理完后采取处理就绪队列。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;最高优先级调度（HPF-Highest Priority First）
    &lt;ul&gt;
      &lt;li&gt;选择优先级最高的进程投入运行&lt;/li&gt;
      &lt;li&gt;系统进程高于用户进程；前台进程高于后台进程；操作系统更偏好I/O进程&lt;/li&gt;
      &lt;li&gt;饥饿现象&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;多级反馈队列（Multiple feedback queue）&lt;/li&gt;
  &lt;li&gt;最短进程优先（Shortest Process Next）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优先级翻转问题（Priority Inversion）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一个低优先级进程持有一个高优先级进程所需要的资源，使得高优先级进程等待低优先级进程运行&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;临界区&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;系统错误，高优先级进程停滞不前，导致系统性能降低&lt;/li&gt;
  &lt;li&gt;解决方案
    &lt;ul&gt;
      &lt;li&gt;设置优先级上限，使进入临界区的进程优先级最高&lt;/li&gt;
      &lt;li&gt;优先级继承&lt;/li&gt;
      &lt;li&gt;使用中断禁止，进入临界区的进程不响应中断&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;45-多级反馈队列调度算法各种调度算法小结&quot;&gt;4.5 多级反馈队列调度算法、各种调度算法小结&lt;/h2&gt;

&lt;p&gt;Multilevel Feedback&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;多个就绪队列，队列的优先级从高到低&lt;/li&gt;
  &lt;li&gt;队列的时间片从小到大&lt;/li&gt;
  &lt;li&gt;第一级队列为空时，调度第二级队列，以此类推&lt;/li&gt;
  &lt;li&gt;各级队列按照&lt;code class=&quot;highlighter-rouge&quot;&gt;时间片轮转方式&lt;/code&gt;进行调度&lt;/li&gt;
  &lt;li&gt;新创建的进程就绪后，进入第一级队列&lt;/li&gt;
  &lt;li&gt;时间片用完而放弃CPU，进入下一级就绪队列&lt;/li&gt;
  &lt;li&gt;由于阻塞而放弃CPU的进程进入相应的等待队列，一旦等待的事件发生，&lt;code class=&quot;highlighter-rouge&quot;&gt;该进程回到原来的一级就绪队列&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;若允许抢占&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当有一个优先级更高的进程就绪时，可以抢占CPU
    &lt;ul&gt;
      &lt;li&gt;被抢占的进程回到原来一级就绪队列末尾&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/blog/images/os4.png&quot; alt=&quot;algorithm&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;多处理器调度算法&quot;&gt;多处理器调度算法&lt;/h3&gt;

&lt;p&gt;算法设计&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不仅要决定选择哪一个进程执行，还需要决定在哪一个CPU上执行&lt;/li&gt;
  &lt;li&gt;要考虑进程在多个CPU之间迁移时的开销&lt;/li&gt;
  &lt;li&gt;考虑负载均衡问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;windows的线程调度算法&quot;&gt;Windows的线程调度算法&lt;/h2&gt;

&lt;p&gt;UNIX: 动态优先数法&lt;/p&gt;

&lt;p&gt;5.3BSD: 多级反馈队列法&lt;/p&gt;

&lt;p&gt;Linux: 抢占式调度&lt;/p&gt;

&lt;p&gt;Solaris: 综合调度算法&lt;/p&gt;

&lt;p&gt;Windows: 基于优先级的抢占式多任务调度&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;支持内核级线程，调度单位是线程&lt;/li&gt;
  &lt;li&gt;采用基于动态优先级的、抢占式调度，结合时间配额的调整&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;就绪线程&lt;/code&gt;按优先队列进入相应队列&lt;/li&gt;
  &lt;li&gt;系统总是选择&lt;code class=&quot;highlighter-rouge&quot;&gt;优先级最高的就绪线程&lt;/code&gt;运行&lt;/li&gt;
  &lt;li&gt;同一优先级的各线程按&lt;code class=&quot;highlighter-rouge&quot;&gt;时间片轮转&lt;/code&gt;进行调度&lt;/li&gt;
  &lt;li&gt;多CPU系统中允许多个线程&lt;code class=&quot;highlighter-rouge&quot;&gt;并行&lt;/code&gt;运行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;引发线程调度的条件：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一个线程的优先级改变了&lt;/li&gt;
  &lt;li&gt;一个线程改变了它的&lt;code class=&quot;highlighter-rouge&quot;&gt;亲和（Affinity）处理机集合&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;线程正常终止或由于某种错误而终止&lt;/li&gt;
  &lt;li&gt;新线程创建或一个等待线程变就绪&lt;/li&gt;
  &lt;li&gt;当一个线程从运行态变阻塞态&lt;/li&gt;
  &lt;li&gt;当一个线程从运行态变就绪态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Windows使用32个线程优先级，分成三类&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;实时优先级线程不改变其优先级&lt;/li&gt;
  &lt;li&gt;可变优先级线程：其优先级可以在一定范围内升高或降低
    &lt;ul&gt;
      &lt;li&gt;基本优先级和当前优先级&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;零页线程：用于对系统中空闲物理页面清零&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程的时间配额&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不是时间，而是一个被称为配额单位（quantum unit）的整数&lt;/li&gt;
  &lt;li&gt;一个线程用完了自己的时间配额时，如果没有其他相同优先级的线程，Windows将重新给该线程分配一个新的时间配额，让它继续运行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;抢占&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;线程被抢占时，会被放回队首
    &lt;ol&gt;
      &lt;li&gt;若是实时优先级的线程被抢占，会被重新分配一个完整的时间配额&lt;/li&gt;
      &lt;li&gt;若是可变优先级的线程被抢占，会继续使用剩余的时间配额&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下列5中情况，Windows会提升线程的优先级&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;I/O操作完成 “Wdm.h”,”Ntddk.h”,IoCompleteRequest&lt;/li&gt;
  &lt;li&gt;信号量或事件等待结束&lt;/li&gt;
  &lt;li&gt;前台进程中的线程完成一个等待操作&lt;/li&gt;
  &lt;li&gt;由于窗口活动而唤醒窗口线程&lt;/li&gt;
  &lt;li&gt;线程处于就绪态超过了一定的时间还没有运行–“饥饿”现象 平衡集管理器(balance set manager)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;5同步机制1&quot;&gt;5.同步机制(1)&lt;/h1&gt;

&lt;p&gt;同步互斥机制&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;进程的并发执行&lt;/li&gt;
  &lt;li&gt;进程互斥&lt;/li&gt;
  &lt;li&gt;进程同步&lt;/li&gt;
  &lt;li&gt;信号量及PV操作&lt;/li&gt;
  &lt;li&gt;经典IPC问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;进程的并发执行&quot;&gt;进程的并发执行&lt;/h2&gt;

&lt;h2 id=&quot;进程互斥&quot;&gt;进程互斥&lt;/h2&gt;

&lt;p&gt;竞争条件（RACE CONDITION）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进程互斥（MUTUAL EXCLUSIVE）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;各个进程竞争使用临界资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;临界资源（CRITICAL RESOURCE）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;系统中某些资源一次只允许一个进程使用，称这样的资源为&lt;code class=&quot;highlighter-rouge&quot;&gt;临界资源&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;互斥资源&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;共享变量&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;临界区（互斥区）：（CRITICAL SECTION）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;各个进程中对某个临界资源实施操作的程序片段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;临界区的使用原则&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;没有进程在临界区时，想进入临界区的进程可进入&lt;/li&gt;
  &lt;li&gt;不允许两个进程同时处于临界区中&lt;/li&gt;
  &lt;li&gt;临界区外运行的进程不得阻塞其他进程进入临界区&lt;/li&gt;
  &lt;li&gt;不得使进程无限期等待进入临界区&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现临界区互斥的方案&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;软件方案 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dekker解法，Peterson解法&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;硬件方案 &lt;code class=&quot;highlighter-rouge&quot;&gt;屏蔽中断，TSL(XCHG)指令&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;进程互斥的软件解决方案&quot;&gt;进程互斥的软件解决方案&lt;/h2&gt;

&lt;p&gt;Dekker算法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1965年，第一个软件解法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Peterson算法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1981年
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;enter_region&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//code
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leave_region&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;54-进程互斥的硬件解决方案&quot;&gt;5.4 进程互斥的硬件解决方案&lt;/h2&gt;

&lt;h3 id=&quot;硬件方法1中断屏蔽方法&quot;&gt;硬件方法1–中断屏蔽方法&lt;/h3&gt;

&lt;p&gt;“开关中断”指令&lt;/p&gt;

&lt;p&gt;算法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;关中断&lt;/code&gt;指令&lt;/li&gt;
  &lt;li&gt;临界区操作&lt;/li&gt;
  &lt;li&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;开中断&lt;/code&gt;指令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;简单，高效&lt;/li&gt;
  &lt;li&gt;代价高，限制CPU并发能力（临界区大小）&lt;/li&gt;
  &lt;li&gt;不适用于多处理器&lt;/li&gt;
  &lt;li&gt;适用于操作系统本身，不适用用户进程&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;硬件方法2测试并加锁指令&quot;&gt;硬件方法2–“测试并加锁”指令&lt;/h3&gt;

&lt;p&gt;TSL指令：TEST AND SET LOCK&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TSL执行前把&lt;code class=&quot;highlighter-rouge&quot;&gt;总线&lt;/code&gt;锁住，结束后把总线打开&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;enter_region:
    TSL REGISTER,LOCK   ;复制锁到寄存器并将锁置1
    CMP REGISTER,#0     ;判断寄存器内容是否是0
    JNE enter_region    ;若不是0，跳转到enter_region
    RET                 ;返回调用者，进入了临界区
leave_region:
    MOVE LOCK,#0        ;在锁中置0
    RET                 ;返回调用者
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;硬件方法3交换指令&quot;&gt;硬件方法3–“交换”指令&lt;/h3&gt;

&lt;p&gt;XCHG指令：EXCHANGE&lt;/p&gt;

&lt;p&gt;类似于TSL指令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;enter_region:
    MOVE REGISTER,#1    ;给寄存器存1
    XCHG REGISTER,LOCK  ;交换寄存器和锁变量的内容
    CMP REGISTER,#0     ;判断寄存器内容是否是0
    JNE enter_region    ;若不是0，跳转到enter_region
    RET                 ;返回调用者，进入了临界区
leave_region:
    MOVE LOCK,#0        ;在锁中置0
    RET                 ;返回调用者
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;忙等待（busy waiting）,自旋锁（spin lock）&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;优先级翻转&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;55-进程同步&quot;&gt;5.5 进程同步&lt;/h2&gt;

&lt;p&gt;进程同步（synchronization）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;指系统中多个进程中发生的事件存在某种时序关系，需要相互合作，共同完成某一项任务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;生产者/消费者问题&lt;/p&gt;

&lt;h2 id=&quot;56-信号量及pv操作&quot;&gt;5.6 信号量及PV操作&lt;/h2&gt;

&lt;p&gt;一种卓有成效的进程同步机制&lt;/p&gt;

&lt;p&gt;1965年，由荷兰学者Dijkstra提出&lt;/p&gt;

&lt;p&gt;定义如下&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;queueType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对信号量可以实施的操作：初始化、P和V&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;P、V分别是荷兰语的test(proberen)和increment(verhogen)&lt;/li&gt;
  &lt;li&gt;P,down,semWait&lt;/li&gt;
  &lt;li&gt;V,up,semSignal&lt;/li&gt;
  &lt;li&gt;PV操作为原语操作（primitive or atomic action）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用PV操作解决进程间互斥问题&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;分析并发进程的关键活动，划定临界区&lt;/li&gt;
  &lt;li&gt;设置信号量mutex，初值为1&lt;/li&gt;
  &lt;li&gt;在临界区前实施P(mutex)&lt;/li&gt;
  &lt;li&gt;在临界区后实施V(mutex)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//该进程状态置为阻塞状态；
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//将该进程插入相应的等待队列s.queue末尾；
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//重新调度；
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//唤醒相应等待队列s.queue中等待的另一个进程
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//改变其状态为就绪态，并将其插入就绪队列
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;57-生产者消费者问题&quot;&gt;5.7 生产者消费者问题&lt;/h2&gt;

&lt;p&gt;信号量方法&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;produce_item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;insert_item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remove_item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;consume_item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;58-读者写者问题&quot;&gt;5.8 读者写者问题&lt;/h2&gt;

&lt;p&gt;问题描述：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;多个进程共享一个数据区，这些进程分成两组
    &lt;ul&gt;
      &lt;li&gt;读者进程：只读数据区中的数据&lt;/li&gt;
      &lt;li&gt;写者进程：只往数据区写数据&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要求满足条件：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;允许多个读者同时执行读操作&lt;/li&gt;
  &lt;li&gt;不允许多个写者同时操作&lt;/li&gt;
  &lt;li&gt;不允许读者、写者同时操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一类读者写者问题：读者优先&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;写操作&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;6-同步机制2&quot;&gt;6. 同步机制（2）&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;管程 monitor&lt;/li&gt;
  &lt;li&gt;进程间通信 inter-process communication&lt;/li&gt;
  &lt;li&gt;典型操作系统的IPC机制&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;61-管程的基本概念&quot;&gt;6.1 管程的基本概念&lt;/h1&gt;

&lt;p&gt;为什么会出现管程:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;信号量机制存在不足：程序编写困难、易出错&lt;/li&gt;
  &lt;li&gt;解决：Brinch Hansen（1973），Hoare（1974）&lt;/li&gt;
  &lt;li&gt;在程序设计语言中引入管程成分，一种高级同步机制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进程与管程&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;进程只能通过调用管程中的过程来间接地访问管程中的数据结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;互斥&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;管程是互斥进入的&lt;/li&gt;
  &lt;li&gt;而互斥性是由编译器负责保证的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同步&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;管程中设置条件变量及等待/唤醒操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;场景：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当一个进入管程的进程执行等待操作时，它应当释放管程的互斥权&lt;/li&gt;
  &lt;li&gt;当后面进入管程的进程执行唤醒操作时（例如P唤醒Q），管程中便存在两个同时处于活动状态的进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;P等待Q执行，Hoare&lt;/li&gt;
  &lt;li&gt;Q等待P继续执行，MESA&lt;/li&gt;
  &lt;li&gt;规定唤醒操作为管程中最后一个可执行的操作，Hansen&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;62-hoare管程&quot;&gt;6.2 HOARE管程&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;因为管程是互斥进入的，所以当一个进程试图进入一个已被占用的管程时，应当在管程的入口处等待
    &lt;ul&gt;
      &lt;li&gt;为此，管程的入口处设置一个进程等待队列，称作&lt;code class=&quot;highlighter-rouge&quot;&gt;入口等待队列&lt;/code&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果进程P唤醒进程Q，则P等待Q执行；如果进程Q执行中又唤醒进程R，则Q等待R执行……，如此在管程内部可能会出现多个等待进程
    &lt;ul&gt;
      &lt;li&gt;在管程内需要设置一个进程等待队列，称为&lt;code class=&quot;highlighter-rouge&quot;&gt;紧急等待队列&lt;/code&gt;，紧急等待队列的优先级&lt;code class=&quot;highlighter-rouge&quot;&gt;高于&lt;/code&gt;入口等待队列的优先级。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;wait(c):&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;紧急等待队列&lt;/code&gt;非空，则唤醒第一个等待者；否则释放管程的互斥权，执行此操作的进程进入c链末尾&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;signal(c):&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果c链为空，则相当于空操作，执行此操作的进程继续执行；否则唤醒第一个等待者，执行此操作的进程进入&lt;code class=&quot;highlighter-rouge&quot;&gt;紧急等待队列&lt;/code&gt;的末尾。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;63-管程的应用&quot;&gt;6.3 管程的应用&lt;/h2&gt;

&lt;p&gt;JAVA中的管程库&lt;/p&gt;

&lt;h2 id=&quot;64-mesa管程&quot;&gt;6.4 MESA管程&lt;/h2&gt;

&lt;p&gt;Hoare管程的一个缺点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;两次额外的进程切换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;signal-&amp;gt;notify&lt;/li&gt;
  &lt;li&gt;notify:当一个正在管程中的进程执行notify(x)时，它使得x条件队列得到通知，发信号的进程继续执行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;notify的结果：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;由于不能保证在它之前没有其他进程进入管程，因而这个进程必须重新检查条件&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;用while循环取得if语句&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;导致对条件变量至少多一次额外的检测（但不再有额外的进程切换），并且对等待进程在notify之后何时运行没有任何限制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;改进notify:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对notify的一个很有用的改进：
    &lt;ul&gt;
      &lt;li&gt;给每个条件原语关联一个监视计时器，不论是否被通知，一个等待时间超时的将被设为就绪态&lt;/li&gt;
      &lt;li&gt;当该进程被调度执行时，会再次检查相关条件，如果条件满足则继续执行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;超时可以防止如下情况的发生：
    &lt;ul&gt;
      &lt;li&gt;当某些进程在产生相关条件的信号之前失败时，等待该条件的进程就会被无限制地推迟执行而处于饥饿状态。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;引入broadcast:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使所有在该条件上等待的进程都被释放并进入就绪队列&lt;/li&gt;
  &lt;li&gt;当一个进程不知道由多少进程将被激活时，这种方式是非常方便的&lt;/li&gt;
  &lt;li&gt;当一个进程难以准确判定将激活哪个进程时，也可使用广播&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;mesa管程与hoare管程的比较&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;mesa管程优于hoare管程之处在于mesa管程错误比较少&lt;/li&gt;
  &lt;li&gt;在mesa管程中，由于每个过程在收到信号后都重新检查管程变量，并且由于使用了while结构，一个进程不正确地broadcast广播或发信号notify不会导致收到信号的程序出错&lt;/li&gt;
  &lt;li&gt;收到信号的程序将检查相关的变量，如果期望的条件没有满足，它会重新继续等待&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;65-pthread中的同步机制&quot;&gt;6.5 PTHREAD中的同步机制&lt;/h2&gt;

&lt;h2 id=&quot;66-进程间通信ipc&quot;&gt;6.6 进程间通信IPC&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;信号量及管程的不足&lt;/li&gt;
  &lt;li&gt;不适用多处理器情况&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;消息传递&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;send &amp;amp; receive 原语&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;适用于：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;分布式系统、基于共享内存的多处理机系统、单处理机系统，可以解决进程间的同步问题、通信问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本通信方式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;消息传递&lt;/li&gt;
  &lt;li&gt;共享内存&lt;/li&gt;
  &lt;li&gt;管道&lt;/li&gt;
  &lt;li&gt;套接字&lt;/li&gt;
  &lt;li&gt;远程过程调用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;67-典型操作系统中的ipc机制&quot;&gt;6.7 典型操作系统中的IPC机制&lt;/h2&gt;

&lt;p&gt;Linux内核同步机制&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;原子操作、自旋锁、读写自旋锁、信号量、读写信号量、互斥体、完成变量、顺序锁、屏障&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原子操作&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;atomic_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atomic_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;atomic_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;atomic_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;atomic_inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;屏障 barrier&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一组线程协同完成一项任务，需要所有线程都到达一个汇合点后再一起向前推进&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;7-存储模型1&quot;&gt;7. 存储模型（1）&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;基本概念&lt;/li&gt;
  &lt;li&gt;物理内存管理&lt;/li&gt;
  &lt;li&gt;伙伴系统&lt;/li&gt;
  &lt;li&gt;基本内存管理方案&lt;/li&gt;
  &lt;li&gt;交换技术（Swapping）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;71-基本概念-地址重定位&quot;&gt;7.1 基本概念-地址重定位&lt;/h2&gt;

&lt;p&gt;Relocation,Translation,Mapping&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;地址重定位，也叫地址转换、地址映射、地址翻译&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;程序装载到内存才可以运行&lt;/li&gt;
  &lt;li&gt;多道程序设计模型&lt;/li&gt;
  &lt;li&gt;每个进程由自己的地址空间
    &lt;ul&gt;
      &lt;li&gt;一个进程访问时不能访问另一个进程的地址空间&lt;/li&gt;
      &lt;li&gt;进程不能执行不适合的操作&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;进程中的地址不是最终的物理地址&lt;/li&gt;
  &lt;li&gt;在进程运行前无法计算出物理地址
    &lt;ul&gt;
      &lt;li&gt;因为：不能确定进程被加载到内存什么地方&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，需要&lt;code class=&quot;highlighter-rouge&quot;&gt;地址重定位&lt;/code&gt;的支持&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;逻辑地址（相对地址，虚拟地址）
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;不能用逻辑地址在内存中读取信息&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;物理地址（绝对地址，实地址）
    &lt;ul&gt;
      &lt;li&gt;内存中存储单元的地址，可直接寻址&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了保证CPU执行指令时可正确访问内存单元，需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址，这一过程称为地址重定位&lt;/p&gt;

&lt;p&gt;静态重定位&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换&lt;/li&gt;
  &lt;li&gt;通常软件可以完成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;动态重定位&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在进程执行过程中进行地址变换
    &lt;ul&gt;
      &lt;li&gt;即&lt;code class=&quot;highlighter-rouge&quot;&gt;逐条指令执行时&lt;/code&gt;完成地址转换&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;需要硬件支持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MMU（内存管理单元）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Memory Management Unit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/blog/images/os5.png&quot; alt=&quot;privilege&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;72-物理内存管理&quot;&gt;7.2 物理内存管理&lt;/h2&gt;

&lt;p&gt;空闲内存管理&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;位图&lt;/li&gt;
  &lt;li&gt;空闲区表，已分配区表&lt;/li&gt;
  &lt;li&gt;空闲块链表&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内存分配算法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首次适配 first fit&lt;/li&gt;
  &lt;li&gt;下次适配 next fit&lt;/li&gt;
  &lt;li&gt;最佳适配 best fit&lt;/li&gt;
  &lt;li&gt;最差适配 worst fit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内存回收算法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当某一块归还后，前后空闲空间合并，修改内存空闲区表&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;73-伙伴系统&quot;&gt;7.3 伙伴系统&lt;/h2&gt;

&lt;p&gt;Linux底层内存管理采用&lt;/p&gt;

&lt;p&gt;一种特殊的“分离适配”算法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一种经典的内存分配方案&lt;/li&gt;
  &lt;li&gt;主要思想：将内存按2的幂进行划分，组成若干空闲块链表；查找该链表找到能满足进程需求的最佳匹配块&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先将整个可用空间看作一块，2^u&lt;/li&gt;
  &lt;li&gt;假设进程申请的空间大小为s，如果满足
    &lt;ul&gt;
      &lt;li&gt;‘2^(u-1) &amp;lt; s &amp;lt;= 2^u’,则分配整个块&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;否则，将块划分为两个大小相等的伙伴，大小为2^(u-1)&lt;/li&gt;
  &lt;li&gt;一直划分下去直到产生大于或等于s的最小块&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;74-基本内存管理方案1&quot;&gt;7.4 基本内存管理方案1&lt;/h2&gt;

&lt;p&gt;单一连续区-&amp;gt;固定分区-&amp;gt;可变分区-&amp;gt;页式-&amp;gt;段式-&amp;gt;段页式-&amp;gt;单一连续区&lt;/p&gt;

&lt;p&gt;单一连续区&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一段时间内只有一个进程在内存简单，内存利用率低&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;固定分区&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;把内存空间分割成若干区域，称为分区&lt;/li&gt;
  &lt;li&gt;每个分区的大小可以相同也可以不同&lt;/li&gt;
  &lt;li&gt;分区大小固定不变&lt;/li&gt;
  &lt;li&gt;每个分区装一个且只能装一个进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可变分区&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;根据进程的需要，把内存空闲空间分割出一个分区，分配给该进程&lt;/li&gt;
  &lt;li&gt;剩余部分成为新的空闲区&lt;/li&gt;
  &lt;li&gt;外碎片，导致内存利用率下降&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;碎片问题解决&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;紧缩技术（memory compaction）
    &lt;ul&gt;
      &lt;li&gt;在内存移动程序，将所有小的空闲区合并为较大的空闲区&lt;/li&gt;
      &lt;li&gt;又称：压缩技术，紧致技术，搬家技术&lt;/li&gt;
      &lt;li&gt;要考虑的问题：系统开销，移动时机&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;75-基本内存管理方案2&quot;&gt;7.5 基本内存管理方案2&lt;/h2&gt;

&lt;h3 id=&quot;页式存储管理方案&quot;&gt;页式存储管理方案&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;用户进程地址空间被划分为大小相等的部分，称为页（Page）或页面，从0开始编号&lt;/li&gt;
  &lt;li&gt;内存空间按同样大小划分为大小相等的区域，称为页框（Page Frame），从0开始编号；也称为物理页面，页帧，内存块&lt;/li&gt;
  &lt;li&gt;内存分配（规则）
    &lt;ul&gt;
      &lt;li&gt;以页为单位进行分配，并按进程需要的页数来分配；逻辑上相邻的页，物理上不一定相邻&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;典型页面尺寸：4K或4M&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;逻辑地址（假设32位机器）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;20位页号，12位页内地址（偏移）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;页表&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;页号&lt;/li&gt;
  &lt;li&gt;页表项
    &lt;ul&gt;
      &lt;li&gt;记录了逻辑页号与页框号的对应关系&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;逻辑地址-&amp;gt;页表（mapping）-&amp;gt;物理内存&lt;/p&gt;

&lt;p&gt;空闲数据管理&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;位图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;地址转换（硬件支持）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CPU取到逻辑地址，自动划分为页号和页内地址，用页号查页表，得到页框号，在与页内偏移拼接成物理地址&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内碎片&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;比如进程需要5页加一条指令，由于这种内存分配方案，我们必须分配6页，这就造成了内存浪费&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;段式存储管理方案&quot;&gt;段式存储管理方案&lt;/h3&gt;

&lt;p&gt;设计思想&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;用户进程地址空间：按程序自身的逻辑关系划分为若干个程序段，每个程序段都有一个段名&lt;/li&gt;
  &lt;li&gt;内存空间被动态划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定&lt;/li&gt;
  &lt;li&gt;内存分配（规则）：以段为单位进行分配，每段在内存中占据连续空间，但各段之间可以不相邻&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;逻辑地址&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;段号，段内地址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;段表&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;段号，段首地址，段长度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;地址转换&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CPU取到逻辑地址，用段号查段表，得到该段在内存的起始地址，与段内偏移地址计算出物理地址&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;段页式存储管理方案&quot;&gt;段页式存储管理方案&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;产生背景
    &lt;ul&gt;
      &lt;li&gt;综合页式，段式方案的优点，克服二者的弱点&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用户进程划分
    &lt;ul&gt;
      &lt;li&gt;先按段划分，每一段再按页面划分&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;逻辑地址
    &lt;ul&gt;
      &lt;li&gt;段号，页号，页内地址&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内存划分：同页式存储管理方案&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内存分配：以页为单位进行分配&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;数据结构及有关操作
    &lt;ul&gt;
      &lt;li&gt;段表，页表&lt;/li&gt;
      &lt;li&gt;段表：记录了每一段的页表始址和页表长度&lt;/li&gt;
      &lt;li&gt;页表：记录了逻辑页号与页框号的对应关系
        &lt;ul&gt;
          &lt;li&gt;每一段有一张页表，一个进程有多个页表&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;空闲区管理：同页式管理&lt;/li&gt;
      &lt;li&gt;内存分配、回收：同页式管理&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;76-交换技术&quot;&gt;7.6 交换技术&lt;/h2&gt;

&lt;p&gt;内存不足时如何管理&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一个大的进程地址空间如何装进一个小的物理内存里面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内存“扩充”技术&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;内存紧缩技术&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;覆盖技术-overlaying&quot;&gt;覆盖技术 overlaying&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;主要用于早期系统
程序执行过程中，程序的不同部分在内存中相互替代
    * 按照其自身的逻辑结构，将那些不会同时执行的程序段共享同一块内存区域
    * 要求程序各模块之间有明确的调用结构
程序员声明覆盖结构，操作系统自动完成覆盖
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;交换技术-swapping&quot;&gt;交换技术 swapping&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;设计思想
    内存空间紧张时，系统将内存中某些进程暂时移到外存，把外存中某些进程换进内存，占据前者所占用的区域（进程在内存及磁盘之间的动态调度）

问题
    1. 进程的哪些内容要交换到磁盘？会遇到什么困难？
        答：运行时创建或修改的内容：栈和堆
    2. 在磁盘的什么位置保存被换出的进程？
        答：交换区：一般系统会指定一块特殊的磁盘区域作为交换空间（swap space），包括连续的磁道，操作系统可以使用底层的磁盘读写操作对其高效访问
    3. 交换时机
        答：只要不用就换出（很少再用）；内存空间不够；有不够的危险
    4. 如何选择被换出的进程
        答：不应换出处等待于I/O状态的进程
    5. 如何处理进程空间增长
        答：同向增长，对向增长
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;虚拟存储技术 virtual memory&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;8-虚拟存储技术&quot;&gt;8 虚拟存储技术&lt;/h1&gt;

&lt;h2 id=&quot;81-虚拟存储技术&quot;&gt;8.1 虚拟存储技术&lt;/h2&gt;

&lt;p&gt;当进程运行时，现将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存的工作&lt;/p&gt;

&lt;p&gt;虚拟地址空间&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;分配给进程的虚拟内存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虚拟地址&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在虚拟内存中指令或数据的位置，该位置可以被访问，仿佛它是内存的一部分&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虚存是对内存的抽象，构建在存储体系之上，由操作系统协调各存储器的使用&lt;/p&gt;

&lt;p&gt;地址保护&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;确保每个进程有独立的地址空间&lt;/li&gt;
  &lt;li&gt;确保进程访问合法的地址范围&lt;/li&gt;
  &lt;li&gt;确保进程的操作是合法的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;虚拟页式paging&quot;&gt;虚拟页式（PAGING）&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;虚拟存储技术 + 页式存储管理方案 -&amp;gt; 虚拟页式存储管理系统
基本思想：
    1.进程开始运行之前，不是装入全部页面，而是装入一个或零个页面
    2.之后，根据进程运行的需要，动态装入其他页面
    3.当内存空间已满，而又需要装入新的页面时，则根据某种算法置换内存中的某个页面，以便装入新的页面
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有两种调页方式&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;请求调页（demand paging）&lt;/li&gt;
  &lt;li&gt;预先调页（prepaging）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以CPU时间和磁盘空间换取昂贵的内存空间&lt;/p&gt;

&lt;h2 id=&quot;82-页表及页表项的设计&quot;&gt;8.2 页表及页表项的设计&lt;/h2&gt;

&lt;p&gt;页表项&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;页框位&lt;/li&gt;
  &lt;li&gt;有效位&lt;/li&gt;
  &lt;li&gt;访问位&lt;/li&gt;
  &lt;li&gt;修改位&lt;/li&gt;
  &lt;li&gt;保护位&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常，页表项是硬件设计的&lt;/p&gt;

&lt;p&gt;页目录&lt;/p&gt;

&lt;p&gt;%cr3&lt;/p&gt;

&lt;p&gt;反转（倒排）页表设计&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从物理地址空间出发，系统建立一张页表&lt;/li&gt;
  &lt;li&gt;页表项记录进程i的某虚拟地址（虚页号）与页框号的映射关系&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;83-地址转换过程及tlb的引入&quot;&gt;8.3 地址转换过程及TLB的引入&lt;/h2&gt;

&lt;p&gt;块表（TLB）的引入&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一种随机存取型存储器，除连线寻址机制外，还有接线逻
辑，能按特定的匹配标志在一个存储周期内对所有的字同
时进行比较&lt;/li&gt;
  &lt;li&gt;页表 -&amp;gt; 两次或两次以上的内存访问&lt;/li&gt;
  &lt;li&gt;基于程序访问的局部性&lt;/li&gt;
  &lt;li&gt;Translation Look-aside buffer&lt;/li&gt;
  &lt;li&gt;相联存储器(associative memory)
    &lt;ul&gt;
      &lt;li&gt;特点：按内容并行查找&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;84-页错误page-fault&quot;&gt;8.4 页错误(Page Fault)&lt;/h2&gt;

&lt;p&gt;具体原因&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;所访问的虚拟页面没有调入物理内存&lt;/li&gt;
  &lt;li&gt;页面访问违反权限&lt;/li&gt;
  &lt;li&gt;错误的访问地址&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;85-软件相关策略&quot;&gt;8.5 软件相关策略&lt;/h2&gt;

&lt;p&gt;驻留集&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;固定分配策略&lt;/li&gt;
  &lt;li&gt;可变分配策略&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;置换问题&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;置换范围
    &lt;ol&gt;
      &lt;li&gt;局部置换&lt;/li&gt;
      &lt;li&gt;全局置换&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;置换策略
    &lt;ol&gt;
      &lt;li&gt;大部分策略是基于过去的行为来预测将来的行为&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;页框锁定&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;操作系统的核心代码、关键数据结构、I/O缓冲区&lt;/li&gt;
  &lt;li&gt;Windows中的VirtualLock和VirtualUnLock函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;清除策略&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在系统中保存一定数目的空闲页框供给比使用所有内存并在需要时搜索一个页框有更好的性能&lt;/li&gt;
  &lt;li&gt;分页守护进程（paging daemon）&lt;/li&gt;
  &lt;li&gt;当进程需要使用一个已置换出的页框时，如果该页框还没有被新的内容覆盖，将它从空闲页框集合中移出即可恢复该页面&lt;/li&gt;
  &lt;li&gt;页缓冲技术
    &lt;ul&gt;
      &lt;li&gt;不丢弃置换出的页，将它们放入两个表之一：空闲页链表，修改页链表&lt;/li&gt;
      &lt;li&gt;将被修改的页定期写入磁盘&lt;/li&gt;
      &lt;li&gt;被置换的页仍然保留在内存中，一旦进程又要访问该页，可以迅速将它加入该进程的驻留集合（代价很小）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;86-页面置换算法1&quot;&gt;8.6 页面置换算法1&lt;/h2&gt;

&lt;p&gt;最佳页面置换算法（OPT）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;设计思想
    &lt;ul&gt;
      &lt;li&gt;置换以后不再需要的或最远的将来才会用到的页面&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先进先出算法（FIFO）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;选择在内存中驻留时间最长的页并置换它&lt;/li&gt;
  &lt;li&gt;实现：页面链表法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二次机会算法（SCR）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;按照先进先出算法选择某一页面，检测其访问位R，如果为0，则置换该页；如果为1，则给第二次机会，并将访问位置0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;时钟算法（CLOCK）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;改进的第二次机会算法&lt;/li&gt;
  &lt;li&gt;用指针的移动代替页框的移动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最近未使用算法（NRU）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;选择在最近一段时间内未使用过的一页并置换&lt;/li&gt;
  &lt;li&gt;根据R、M的情况分为4类&lt;/li&gt;
  &lt;li&gt;随机从编号最小的非空类中选择一页置换&lt;/li&gt;
  &lt;li&gt;时钟算法的实现
    &lt;ol&gt;
      &lt;li&gt;从指针的当前位置开始，扫描页框缓冲区，选择遇到的第一个页框（r=0;m=0），用于置换（本次扫描过程中，对使用位不做任何修改）&lt;/li&gt;
      &lt;li&gt;如果第1步失败，则重新扫描，选择第一个（r=0;m=1）的页框（本次扫描过程中，对每个跳过的页框，将其使用位设置成0）&lt;/li&gt;
      &lt;li&gt;如果第2步失败，指针将回到它的最初位置，并且集合中所有页框的使用位均为0。重复第1步，并且，如果有必要，重复第2步。这样将可以找到供置换的页框&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最近最少使用算法（LRU）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;选择最后一次访问时间距离当前时间最长的一页并置换&lt;/li&gt;
  &lt;li&gt;实现：时间戳，维护一个访问页的栈
    &lt;ul&gt;
      &lt;li&gt;开销大&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;一种硬件实现方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最不经常使用算法（NFU）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;选择访问次数最少的页面置换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;老化算法（AGING）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;改进：计数器在加R前先右移一位，R位加到计数器的最左端&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BELADY现象&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;FIFO页面置换算法会产生异常现象，即：当分配给进程的物理页面增加时，缺页次数反而增加&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;87-页面置换算法2-工作集算法&quot;&gt;8.7 页面置换算法2-工作集算法&lt;/h2&gt;

&lt;p&gt;影响缺页次数的因素&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;页面置换算法&lt;/li&gt;
  &lt;li&gt;页面本身的大小&lt;/li&gt;
  &lt;li&gt;程序的编制方法&lt;/li&gt;
  &lt;li&gt;分配给进程的页框数量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;颠簸（Thrashing,抖动）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;虚存中，页面在内存与磁盘之间频繁调度，使得调度页面所需的时间比进程实际运行的时间还多，这样导致系统效率急剧下降，这种现象称为颠簸或抖动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;页面尺寸&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;确定页面大小对于分页的硬件设计非常重要而对操作系统是个可选的参数&lt;/li&gt;
  &lt;li&gt;x86/Pentium 4096 或 4M&lt;/li&gt;
  &lt;li&gt;最优页面大小：P=根号下2se&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;程序编制方法对缺页次数的影响&lt;/p&gt;

&lt;p&gt;工作集（working set）模型&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;根据程序的局部性原理，一般情况下，进程在一段时间内总是集中访问一些页面，这些页面称为活跃页面，如果分配给一个进程的物理页面数太少了，使该进程所需的活跃页面不能全部装入内存，则进程在运行过程中将频繁发生中断&lt;/li&gt;
  &lt;li&gt;一个进程当前正在使用的页框集合&lt;/li&gt;
  &lt;li&gt;访页序列特性、时刻t、工作集窗口长度&lt;/li&gt;
  &lt;li&gt;基本思路：
    &lt;ul&gt;
      &lt;li&gt;找出一个不在工作集中的页面并置换它&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;88-其他相关技术&quot;&gt;8.8 其他相关技术&lt;/h2&gt;

&lt;p&gt;内存映射文件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;mmap&lt;/li&gt;
  &lt;li&gt;进程通过一个系统调用(mmap)讲一个文件映射到其虚拟地址空间的一部分，访问这个文件就像访问内存中的一个大数组，而不是对文件进行读写&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;支持写时复制技术&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;新复制的页面对执行写操作的进程是私有的，对其他共享写时复制页面的进程是不可见的&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;9-文件系统1&quot;&gt;9 文件系统（1）&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;文件与文件系统&lt;/li&gt;
  &lt;li&gt;文件的存储介质&lt;/li&gt;
  &lt;li&gt;磁盘空间管理&lt;/li&gt;
  &lt;li&gt;文件控制块及文件目录&lt;/li&gt;
  &lt;li&gt;文件的物理结构&lt;/li&gt;
  &lt;li&gt;文件系统的实现&lt;/li&gt;
  &lt;li&gt;文件系统实例–UNIX&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;91-文件与文件系统&quot;&gt;9.1 文件与文件系统&lt;/h2&gt;

&lt;p&gt;文件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;是对磁盘的抽象&lt;/li&gt;
  &lt;li&gt;是指一组带标识（标识即文件名）的、在逻辑上有完整意义的信息项的序列&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文件系统&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;统一管理磁盘空间，实施磁盘空间的分配与回收&lt;/li&gt;
  &lt;li&gt;实现文件的按名存取
    &lt;ul&gt;
      &lt;li&gt;名字空间-&amp;gt;磁盘空间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;实现文件信息的共享，并提供文件的保护、保密手段&lt;/li&gt;
  &lt;li&gt;向用户提供一个方便使用、易于维护的接口、并向用户提供有关统计信息&lt;/li&gt;
  &lt;li&gt;提高文件系统的性能&lt;/li&gt;
  &lt;li&gt;提供与I/O系统的统一接口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按文件性质和用途分类（UNIX）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;普通文件；目录文件；特殊文件（设备文件）；管道文件；套接字&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;普通文件：包含了用户的信息，一般为ASCII或二进制文件&lt;/p&gt;

&lt;p&gt;目录文件：管理文件系统的系统文件&lt;/p&gt;

&lt;p&gt;特殊文件：字符设备文件；块设备文件&lt;/p&gt;

&lt;p&gt;流式文件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文件是由逻辑意义、无结构的一串字符的集合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;记录式文件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每条记录有其内部结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;顺序访问&lt;/p&gt;

&lt;p&gt;随机访问&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;提供读写位置（UNIX的seek操作）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;92-文件的存储介质&quot;&gt;9.2 文件的存储介质&lt;/h2&gt;

&lt;p&gt;物理块（块block、簇cluster）&lt;/p&gt;

&lt;p&gt;磁盘结构&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;物理地址形式：磁头号（盘面号）、磁道号（柱面号）、扇区号&lt;/li&gt;
  &lt;li&gt;扇区：标题（10字节）、数据（512字节）、ECC纠错信息（12-16字节）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一次访盘请求&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;读/写，磁盘地址（设备号，柱面号，磁头号，扇区号），内存地址（源/目）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完成过程由三个动作组成&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;寻道（时间）
    &lt;ul&gt;
      &lt;li&gt;磁头移动定位到指定磁道&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;旋转延迟（时间）
    &lt;ul&gt;
      &lt;li&gt;等待指定扇区从磁头上旋转经过&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据传输（时间）
    &lt;ul&gt;
      &lt;li&gt;数据在磁盘与内存之间的实际传输&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;93-磁盘空间管理&quot;&gt;9.3 磁盘空间管理&lt;/h2&gt;

&lt;p&gt;有关数据结构&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;位图&lt;/li&gt;
  &lt;li&gt;空闲块表&lt;/li&gt;
  &lt;li&gt;空闲块链表&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;磁盘地址与块号的转换&lt;/p&gt;

&lt;p&gt;成组链接法&lt;/p&gt;

&lt;h2 id=&quot;94-文件控制块及文件目录&quot;&gt;9.4 文件控制块及文件目录&lt;/h2&gt;

&lt;p&gt;文件控制块（File Control Block）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;为管理文件而设置的数据结构，保存管理文件所需的所有有关信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文件目录、目录项、目录文件&lt;/p&gt;

&lt;h2 id=&quot;95-文件的物理结构&quot;&gt;9.5 文件的物理结构&lt;/h2&gt;

&lt;p&gt;连续结构&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;优点
    &lt;ul&gt;
      &lt;li&gt;简单&lt;/li&gt;
      &lt;li&gt;支持顺序存取和随机存取&lt;/li&gt;
      &lt;li&gt;所需的磁盘寻道次数和寻道时间最少&lt;/li&gt;
      &lt;li&gt;可以同时读入多个块，检索一个块也很容易&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缺点
    &lt;ul&gt;
      &lt;li&gt;文件不能动态增长
        &lt;ul&gt;
          &lt;li&gt;预留空间：浪费或重新分配和移动&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;不利于文件插入和删除&lt;/li&gt;
      &lt;li&gt;外部碎片：紧缩技术&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;链接结构&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一个文件的信息存在若干不连续的物理块中，各块之间通过直接连接，前一个物理块指向下一个物理块&lt;/li&gt;
  &lt;li&gt;优点
    &lt;ul&gt;
      &lt;li&gt;提高了磁盘空间利用率，不存在外部碎片问题&lt;/li&gt;
      &lt;li&gt;有利于文件插入和删除&lt;/li&gt;
      &lt;li&gt;有利于文件动态扩充&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缺点
    &lt;ul&gt;
      &lt;li&gt;存取速度慢，不适于随机存取&lt;/li&gt;
      &lt;li&gt;可靠性，如指针出错&lt;/li&gt;
      &lt;li&gt;更多的寻道次数和寻道时间&lt;/li&gt;
      &lt;li&gt;链接指针占用一定的空间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文件分配表（FAT）&lt;/p&gt;

&lt;p&gt;索引结构&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;保持了链接结构的优点，又解决了其缺点
    &lt;ul&gt;
      &lt;li&gt;优点
        &lt;ul&gt;
          &lt;li&gt;既能顺序存取，又能随机存取&lt;/li&gt;
          &lt;li&gt;满足了文件动态增长、插入删除的要求&lt;/li&gt;
          &lt;li&gt;能充分利用磁盘空间&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;缺点
        &lt;ul&gt;
          &lt;li&gt;较多的寻道次数和寻道时间&lt;/li&gt;
          &lt;li&gt;索引表本身带来了系统开销&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多级索引与综合模式&lt;/p&gt;

&lt;p&gt;UNIX的三级索引结构&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个文件的主索引表有15个索引项（FCB中），每项2个字节&lt;/li&gt;
  &lt;li&gt;前12项直接存放文件的物理块号（直接寻址）&lt;/li&gt;
  &lt;li&gt;如果文件大于12块，则利用第13项指向一个物理块，在该块中存放的是一级索引表
    &lt;ul&gt;
      &lt;li&gt;假设扇区大小为512字节，物理块等于扇区块大小，一级索引表可以存放256个物理块号&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对于更大的文件还可利用第14和第15项作为二级和三级索引表
    &lt;ul&gt;
      &lt;li&gt;二级索引表的每个索引项指向一个一级索引表&lt;/li&gt;
      &lt;li&gt;三级索引表的每个索引项指向一个二级索引表&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;采用这种结构，一个文件最大可达到多少个物理块？&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;12 + 256 + 256^2 + 256^3 个块&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;96-文件系统的实现&quot;&gt;9.6 文件系统的实现&lt;/h2&gt;

&lt;p&gt;磁盘分区（partition）&lt;/p&gt;

&lt;p&gt;文件卷（volume）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;块（Block）和簇（Cluster）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;格式化（format）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在一个文件卷上建立文件系统，即建立并初始化用于文件分配和磁盘空闲空间管理的管理数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;磁盘上的内容&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;引导区&lt;/li&gt;
  &lt;li&gt;卷（分区）信息&lt;/li&gt;
  &lt;li&gt;目录文件（根目录文件及其他目录文件）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/blog/images/os6.png&quot; alt=&quot;os&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;97-文件系统实例unix&quot;&gt;9.7 文件系统实例——UNIX&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/blog/images/os7.png&quot; alt=&quot;os&quot; /&gt;&lt;/p&gt;

&lt;p&gt;目录文件实现时的改进&lt;/p&gt;

&lt;p&gt;UNIX文件系统&lt;/p&gt;

&lt;h1 id=&quot;10-文件系统2todo&quot;&gt;10 文件系统（2）//TODO&lt;/h1&gt;

&lt;h2 id=&quot;101-文件系统实例-fat&quot;&gt;10.1 文件系统实例-FAT&lt;/h2&gt;

&lt;h2 id=&quot;102-文件操作的实现&quot;&gt;10.2 文件操作的实现&lt;/h2&gt;

&lt;h2 id=&quot;103-文件系统的管理&quot;&gt;10.3 文件系统的管理&lt;/h2&gt;

&lt;h2 id=&quot;104-文件系统的安全性&quot;&gt;10.4 文件系统的安全性&lt;/h2&gt;

&lt;h2 id=&quot;105-文件系统的性能1&quot;&gt;10.5 文件系统的性能1&lt;/h2&gt;

&lt;h2 id=&quot;106-文件系统的性能2&quot;&gt;10.6 文件系统的性能2&lt;/h2&gt;

&lt;h2 id=&quot;107-文件系统的性能3&quot;&gt;10.7 文件系统的性能3&lt;/h2&gt;

&lt;h2 id=&quot;108-文件系统的两个练习&quot;&gt;10.8 文件系统的两个练习&lt;/h2&gt;</content><author><name></name></author><summary type="html">1.操作系统概述 操作系统主要特征： 并发，共享，虚拟，随机 并发：同时处理多个活动的能力 活动切换，保护，相互依赖的活动间的同步 共享：共享有限的系统资源 互斥共享 同时共享 虚拟：一个物理实体映射为若干个逻辑实体 随机：对以不可预测的次序发生的事件进行相应并处理 SPOOLING系统（技术） 批处理系统的实现通常采用的技术 分时操作系统 实时操作系统</summary></entry><entry><title type="html">Network</title><link href="http://localhost:4000/blog/2017/10/01/network.html" rel="alternate" type="text/html" title="Network" /><published>2017-10-01T00:00:00+08:00</published><updated>2017-10-01T00:00:00+08:00</updated><id>http://localhost:4000/blog/2017/10/01/network</id><content type="html" xml:base="http://localhost:4000/blog/2017/10/01/network.html">&lt;p&gt;对等实体&lt;/p&gt;</content><author><name></name></author><summary type="html">对等实体</summary></entry><entry><title type="html">Graph</title><link href="http://localhost:4000/blog/2017/10/01/graph.html" rel="alternate" type="text/html" title="Graph" /><published>2017-10-01T00:00:00+08:00</published><updated>2017-10-01T00:00:00+08:00</updated><id>http://localhost:4000/blog/2017/10/01/graph</id><content type="html" xml:base="http://localhost:4000/blog/2017/10/01/graph.html">&lt;h3 id=&quot;动态连通性问题dynamic-connectivity&quot;&gt;动态连通性问题(Dynamic Connectivity)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;union-find算法
    &lt;ul&gt;
      &lt;li&gt;quick-find
        &lt;ul&gt;
          &lt;li&gt;初始时各点的连通分量各不相同；&lt;/li&gt;
          &lt;li&gt;每添加一条边，则检测两点是否属于同一个连通分量；
            &lt;ol&gt;
              &lt;li&gt;若属于，则不做处理，因为不影响连通性；&lt;/li&gt;
              &lt;li&gt;若不属于，则合并这两点所在的连通分量。&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;quick-union
        &lt;ul&gt;
          &lt;li&gt;每添加一条边，则检测两点所在树的根节点是否相同；
            &lt;ol&gt;
              &lt;li&gt;若相同，则不做处理；&lt;/li&gt;
              &lt;li&gt;若不相同，则某一根节点指向另一根节点&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;weighted-quick-union
        &lt;ul&gt;
          &lt;li&gt;记录每棵树的大小，每次合并时，总将小树合并到大树&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;最优算法
    &lt;ul&gt;
      &lt;li&gt;在weighted-quick-union的基础上，压缩路径，开销接近于常数&lt;/li&gt;
      &lt;li&gt;例如，自己想的办法，在find的root时候，将点s直接链到root上&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;这是一类无向图问题&quot;&gt;这是一类无向图问题&lt;/h3&gt;
&lt;p&gt;深度优先搜索（DepthFirstSearch）&lt;/p&gt;

&lt;p&gt;广度优先搜索（BreadthFirstSearch）&lt;/p&gt;

&lt;p&gt;连通分量(Connected Components)&lt;br /&gt;
    用深度优先搜索实现//代码TODO&lt;br /&gt;
    用union-find算法实现//代码TODO&lt;/p&gt;

&lt;p&gt;检测环(Circle Detection)&lt;br /&gt;
    如果顶点v的邻接点w已经被标记，且不是v的父顶点u的话，那必然有另外一条路先于v标记了w，即既有经过v的路径s-&amp;gt;w，又有不经过v的路径s-&amp;gt;w，即构成了环 
    //代码TODO&lt;/p&gt;

&lt;p&gt;双色问题
    如果顶点v的邻接点w已经被染色，且与v同色，则不是一个双色图，即二分图。
    //代码TODO&lt;/p&gt;

&lt;p&gt;符号图（Symbol Graphs）&lt;br /&gt;
    //代码TODO&lt;/p&gt;

&lt;p&gt;间隔的度数（Degrees Of Separation）&lt;br /&gt;
    //代码TODO&lt;/p&gt;

&lt;h3 id=&quot;这是一类有向图问题&quot;&gt;这是一类有向图问题&lt;/h3&gt;
&lt;p&gt;有向无环图（DAG）&lt;br /&gt;
    进行有向环检测确保的确无环;&lt;br /&gt;
    有向无环图才可以进行拓扑排序;&lt;/p&gt;

&lt;p&gt;有向环检测
    若顶点v的邻接顶点w已经被标记，且还在调用栈里面，即既存在v-&amp;gt;w边，也间接存在一条w-&amp;gt;v边，这两者构成一个环，注意去无向的区别&lt;/p&gt;

&lt;p&gt;拓扑排序（topological sort）
    就是有向图的逆后序&lt;br /&gt;
        优先级调度
        无环有向图的最短路径问题
        //代码TODO&lt;/p&gt;

&lt;p&gt;强连通性（Strong connectivity）&lt;br /&gt;
    Kosaraju算法&lt;/p&gt;

&lt;p&gt;Kosaraju算法（Kosaraju–Sharir algorithm）&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;计算一个图G的反向图的逆后序排列&lt;/li&gt;
  &lt;li&gt;按照前述顺序进行DFS&lt;/li&gt;
  &lt;li&gt;一个DFS中被访问到的点属于同一个强连通分量。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;顶点对的可达性（All-pairs reachability）
    传递闭包（transitive closure）&lt;/p&gt;

&lt;h3 id=&quot;这是一类加权无向图问题&quot;&gt;这是一类加权无向图问题&lt;/h3&gt;
&lt;p&gt;最小生成树（Minimum Spanning trees）&lt;br /&gt;
    Prim算法&lt;br /&gt;
    Kruskal算法&lt;/p&gt;

&lt;p&gt;Prim算法
    从一个点开始，将权重最小的横切边添加进树，直到树有V-1个边&lt;br /&gt;
    //延时实现TODO
    在树生长的过程中，点v可能有多条边与树相连，我们只要知道最短那条边就好了
    //非延时实现TODO&lt;/p&gt;

&lt;p&gt;Kruskal算法
    从最小边开始，从不会构成环的相邻边中挑选最小边添加进树，直到树有V-1个边&lt;br /&gt;
    //TODO&lt;/p&gt;

&lt;h3 id=&quot;这是一类加权有向图问题-最短路径&quot;&gt;这是一类加权有向图问题 最短路径&lt;/h3&gt;

&lt;p&gt;边的松弛（Edge relaxation）  
顶点的松弛（Vertex relaxation）&lt;br /&gt;
Dijkstra算法&lt;br /&gt;
    将距离s最近的非树顶点放松并加入树中，如此这般，直到所有的顶点都在树中或者所有的非树顶点离s无限远。&lt;br /&gt;
    //TODO&lt;br /&gt;
若该图是无环的，则
    按照拓扑顺序放松顶点，就能解决最短路径问题&lt;br /&gt;
    //TODO&lt;/p&gt;

&lt;p&gt;最长路径问题
    //TODO&lt;/p&gt;

&lt;p&gt;关键路径（Critical Path）&lt;br /&gt;
    优先级限制下的并行任务调度&lt;br /&gt;
    //TODO&lt;br /&gt;
    相对最后期限下的并行任务调度&lt;br /&gt;
    //TODO&lt;/p&gt;

&lt;p&gt;若不存在负权重环，则&lt;br /&gt;
Bellman-Ford算法&lt;br /&gt;
    以任意顺序放松有向图的所有边，重复V轮&lt;br /&gt;
    //TODO&lt;/p&gt;

&lt;p&gt;基于队列的Bellman-Ford算法&lt;br /&gt;
    基于上轮放松过的顶点本轮才可能放松的认识，优化算法&lt;br /&gt;
    //TODO&lt;/p&gt;

&lt;p&gt;负权重环的检测&lt;br /&gt;
    套汇&lt;br /&gt;
    //TODO&lt;/p&gt;

&lt;p&gt;当且仅当一副含有V个顶点的图G满足下列5个条件之一时，它就是一棵树：&lt;br /&gt;
    G有V-1条边且不含有环；&lt;br /&gt;
    G有V-1条边且是连通的；&lt;br /&gt;
    G是连通的，但删除任意一条边都会使它不再连通；&lt;br /&gt;
    G是无环图，但添加任意一条边都会产生一个环；&lt;br /&gt;
    G中的任意一对顶点之间仅存在一条简单路径。&lt;/p&gt;

&lt;p&gt;二分图（bipartite graph）是一种能够将所有顶点分为两个集合的图，每条边依附（incident）的两个顶点分属两个不同的集合。&lt;/p&gt;

&lt;p&gt;生成树（spanning tree）是一棵含有图所有顶点的树，生成树森林是所有连通分支  （connected components）的生成树的集合。&lt;/p&gt;

&lt;p&gt;解决任务调度类应用通常需要以下3步：&lt;br /&gt;
    指明任务和优先级条件&lt;br /&gt;
    不断检测并去除有向图中的所有环，以确保存在可行方案
    使用拓扑排序解决调度问题&lt;/p&gt;

&lt;p&gt;深度优先搜索（DepthFirstSearch）是这样一种算法：&lt;br /&gt;
    在访问一个顶点时，&lt;br /&gt;
        将它标记为已访问；&lt;br /&gt;
        递归地访问它的所有没有被标记过的相邻（adjacent）顶点。&lt;br /&gt;
        //代码TODO&lt;/p&gt;

&lt;p&gt;他可以被用来：&lt;br /&gt;
    无向图&lt;br /&gt;
        寻找单源路径（single-source paths）//代码TODO &lt;br /&gt;
        寻找图中所有的连通分量//代码TODO&lt;br /&gt;
        检测环//代码TODO&lt;br /&gt;
        双色问题（Two-colorability）//代码TODO&lt;br /&gt;
    有向图&lt;br /&gt;
        单源可达性（Single-source reachability）//代码TODO&lt;br /&gt;
        单点有向路径（DepthFirstDirectedPaths）//代码TODO   &lt;br /&gt;
        有向环检测（Directed cycle detection）//代码TODO
        拓扑排序//代码TODO
        Kosaraju算法//代码TODO&lt;/p&gt;

&lt;p&gt;广度优先搜索（BreadthFirstSearch）是这样一种算法：&lt;br /&gt;
    先将起点加入队列，然后重复下列步骤直到队列为空，&lt;br /&gt;
        取队列的下一个顶点v并标记它；&lt;br /&gt;
        将与v相邻的所有未被标记过的顶点加入队列。&lt;br /&gt;
        //代码TODO&lt;/p&gt;

&lt;p&gt;他可以被用来：&lt;br /&gt;
    无向图&lt;br /&gt;
        寻找单源最短路径（single-source shortest paths）//代码TODO&lt;br /&gt;
        确定间隔的度数（Degrees of separation）//代码TODO，用符号图来实现&lt;br /&gt;
    有向图&lt;br /&gt;
        单点最短有向路径（BreadthFirstDirectedPaths）//代码TODO&lt;/p&gt;</content><author><name></name></author><summary type="html">动态连通性问题(Dynamic Connectivity) union-find算法 quick-find 初始时各点的连通分量各不相同； 每添加一条边，则检测两点是否属于同一个连通分量； 若属于，则不做处理，因为不影响连通性； 若不属于，则合并这两点所在的连通分量。 quick-union 每添加一条边，则检测两点所在树的根节点是否相同； 若相同，则不做处理； 若不相同，则某一根节点指向另一根节点 weighted-quick-union 记录每棵树的大小，每次合并时，总将小树合并到大树 最优算法 在weighted-quick-union的基础上，压缩路径，开销接近于常数 例如，自己想的办法，在find的root时候，将点s直接链到root上 这是一类无向图问题 深度优先搜索（DepthFirstSearch） 广度优先搜索（BreadthFirstSearch） 连通分量(Connected Components) 用深度优先搜索实现//代码TODO 用union-find算法实现//代码TODO 检测环(Circle Detection) 如果顶点v的邻接点w已经被标记，且不是v的父顶点u的话，那必然有另外一条路先于v标记了w，即既有经过v的路径s-&amp;gt;w，又有不经过v的路径s-&amp;gt;w，即构成了环 //代码TODO 双色问题 如果顶点v的邻接点w已经被染色，且与v同色，则不是一个双色图，即二分图。 //代码TODO 符号图（Symbol Graphs） //代码TODO 间隔的度数（Degrees Of Separation） //代码TODO 这是一类有向图问题 有向无环图（DAG） 进行有向环检测确保的确无环; 有向无环图才可以进行拓扑排序; 有向环检测 若顶点v的邻接顶点w已经被标记，且还在调用栈里面，即既存在v-&amp;gt;w边，也间接存在一条w-&amp;gt;v边，这两者构成一个环，注意去无向的区别 拓扑排序（topological sort） 就是有向图的逆后序 优先级调度 无环有向图的最短路径问题 //代码TODO 强连通性（Strong connectivity） Kosaraju算法 Kosaraju算法（Kosaraju–Sharir algorithm） 计算一个图G的反向图的逆后序排列 按照前述顺序进行DFS 一个DFS中被访问到的点属于同一个强连通分量。 顶点对的可达性（All-pairs reachability） 传递闭包（transitive closure） 这是一类加权无向图问题 最小生成树（Minimum Spanning trees） Prim算法 Kruskal算法 Prim算法 从一个点开始，将权重最小的横切边添加进树，直到树有V-1个边 //延时实现TODO 在树生长的过程中，点v可能有多条边与树相连，我们只要知道最短那条边就好了 //非延时实现TODO Kruskal算法 从最小边开始，从不会构成环的相邻边中挑选最小边添加进树，直到树有V-1个边 //TODO 这是一类加权有向图问题 最短路径 边的松弛（Edge relaxation）  顶点的松弛（Vertex relaxation） Dijkstra算法 将距离s最近的非树顶点放松并加入树中，如此这般，直到所有的顶点都在树中或者所有的非树顶点离s无限远。 //TODO 若该图是无环的，则 按照拓扑顺序放松顶点，就能解决最短路径问题 //TODO 最长路径问题 //TODO 关键路径（Critical Path） 优先级限制下的并行任务调度 //TODO 相对最后期限下的并行任务调度 //TODO 若不存在负权重环，则 Bellman-Ford算法 以任意顺序放松有向图的所有边，重复V轮 //TODO 基于队列的Bellman-Ford算法 基于上轮放松过的顶点本轮才可能放松的认识，优化算法 //TODO 负权重环的检测 套汇 //TODO 当且仅当一副含有V个顶点的图G满足下列5个条件之一时，它就是一棵树： G有V-1条边且不含有环； G有V-1条边且是连通的； G是连通的，但删除任意一条边都会使它不再连通； G是无环图，但添加任意一条边都会产生一个环； G中的任意一对顶点之间仅存在一条简单路径。 二分图（bipartite graph）是一种能够将所有顶点分为两个集合的图，每条边依附（incident）的两个顶点分属两个不同的集合。 生成树（spanning tree）是一棵含有图所有顶点的树，生成树森林是所有连通分支 （connected components）的生成树的集合。 解决任务调度类应用通常需要以下3步： 指明任务和优先级条件 不断检测并去除有向图中的所有环，以确保存在可行方案 使用拓扑排序解决调度问题 深度优先搜索（DepthFirstSearch）是这样一种算法： 在访问一个顶点时， 将它标记为已访问； 递归地访问它的所有没有被标记过的相邻（adjacent）顶点。 //代码TODO 他可以被用来： 无向图 寻找单源路径（single-source paths）//代码TODO 寻找图中所有的连通分量//代码TODO 检测环//代码TODO 双色问题（Two-colorability）//代码TODO 有向图 单源可达性（Single-source reachability）//代码TODO 单点有向路径（DepthFirstDirectedPaths）//代码TODO 有向环检测（Directed cycle detection）//代码TODO 拓扑排序//代码TODO Kosaraju算法//代码TODO 广度优先搜索（BreadthFirstSearch）是这样一种算法： 先将起点加入队列，然后重复下列步骤直到队列为空， 取队列的下一个顶点v并标记它； 将与v相邻的所有未被标记过的顶点加入队列。 //代码TODO 他可以被用来： 无向图 寻找单源最短路径（single-source shortest paths）//代码TODO 确定间隔的度数（Degrees of separation）//代码TODO，用符号图来实现 有向图 单点最短有向路径（BreadthFirstDirectedPaths）//代码TODO</summary></entry><entry><title type="html">Cs</title><link href="http://localhost:4000/blog/2017/10/01/cs.html" rel="alternate" type="text/html" title="Cs" /><published>2017-10-01T00:00:00+08:00</published><updated>2017-10-01T00:00:00+08:00</updated><id>http://localhost:4000/blog/2017/10/01/cs</id><content type="html" xml:base="http://localhost:4000/blog/2017/10/01/cs.html">&lt;p&gt;MOS（金属氧化物半导体 Metal-Oxide-Semiconductor）&lt;/p&gt;

&lt;p&gt;N型MOS管&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Gate端连接了高电平，晶体管导通，电流从源（Source）流到漏（Drain）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;P型MOS管&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Gate端连接了低电平，晶体管导通，电流从源（Source）流到漏（Drain）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;第三讲-算术逻辑单元&quot;&gt;第三讲 算术逻辑单元&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;imgs/MOS.png&quot; alt=&quot;MOS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;非门
&lt;img src=&quot;imgs/notgate.png&quot; alt=&quot;非门&quot; /&gt;&lt;/p&gt;

&lt;p&gt;与门
&lt;img src=&quot;imgs/andgate.png&quot; alt=&quot;与门&quot; /&gt;&lt;/p&gt;

&lt;p&gt;或门
&lt;img src=&quot;imgs/orgate.png&quot; alt=&quot;或门&quot; /&gt;&lt;/p&gt;

&lt;p&gt;异或门
&lt;img src=&quot;imgs/xorgate.png&quot; alt=&quot;异或门&quot; /&gt;&lt;/p&gt;

&lt;p&gt;寄存器由32个D触发器构成&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;D触发器
&lt;img src=&quot;imgs/Dflipflop.png&quot; alt=&quot;D触发器&quot; /&gt;
原理
&lt;img src=&quot;imgs/d2.png&quot; alt=&quot;原理&quot; /&gt;
逻辑运算的实现
&lt;img src=&quot;imgs/logicala.png&quot; alt=&quot;逻辑运算&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;加减法的实现&quot;&gt;加减法的实现&lt;/h2&gt;

&lt;p&gt;半加器
&lt;img src=&quot;imgs/halfadd.png&quot; alt=&quot;半加器&quot; /&gt;&lt;/p&gt;

&lt;p&gt;全加器&lt;br /&gt;
&lt;img src=&quot;imgs/fulladd.png&quot; alt=&quot;全加器&quot; /&gt;&lt;/p&gt;

&lt;p&gt;加法的实现(行波进位加法器)
&lt;img src=&quot;imgs/addimpl.png&quot; alt=&quot;加法的实现&quot; /&gt;&lt;/p&gt;

&lt;p&gt;溢出的检查方法&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;“最高位的进位输入“不等于”最高位的进位输出“&lt;br /&gt;
&lt;img src=&quot;imgs/overflow.png&quot; alt=&quot;溢出的检查方法&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;减法的实现&lt;br /&gt;
&lt;img src=&quot;imgs/subimpl.png&quot; alt=&quot;减法的实现&quot; /&gt;&lt;/p&gt;

&lt;p&gt;行波进位加法器
&lt;img src=&quot;imgs/RCA.png&quot; alt=&quot;行波进位加法器&quot; /&gt;
关键路径&lt;br /&gt;
&lt;img src=&quot;imgs/rca-lag.png&quot; alt=&quot;关键路径&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进位输出信号的分析
&lt;img src=&quot;imgs/carry1.png&quot; alt=&quot;进位输出信号&quot; /&gt;
&lt;img src=&quot;imgs/carry2.png&quot; alt=&quot;进位输出信号&quot; /&gt;
&lt;img src=&quot;imgs/cla1.png&quot; alt=&quot;超前进位加法器&quot; /&gt;
&lt;img src=&quot;imgs/cla2.png&quot; alt=&quot;超前进位加法器&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4级CLA的延迟时间为13T&lt;br /&gt;
&lt;img src=&quot;imgs/cla3.png&quot; alt=&quot;超前进位加法器&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;第四讲-乘法器和除法器-todo&quot;&gt;第四讲 乘法器和除法器 //TODO&lt;/h1&gt;

&lt;h1 id=&quot;第五讲-单周期处理器-todo&quot;&gt;第五讲 单周期处理器 //TODO&lt;/h1&gt;
&lt;p&gt;处理器设计的五个步骤&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;分析指令系统，得出对数据通路的需求&lt;/li&gt;
  &lt;li&gt;为数据通路选择合适的组件&lt;/li&gt;
  &lt;li&gt;连接组件建立数据通路&lt;/li&gt;
  &lt;li&gt;分析每条指令的实现，已确定控制信号&lt;/li&gt;
  &lt;li&gt;集成控制信号，形成完整的控制逻辑&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;控制信号的集成//TODO&lt;/p&gt;

&lt;h1 id=&quot;第六讲-流水线处理器&quot;&gt;第六讲 流水线处理器&lt;/h1&gt;

&lt;p&gt;流水线，超标量；双发射，5级流水线&lt;/p&gt;

&lt;h2 id=&quot;结构冒险&quot;&gt;结构冒险&lt;/h2&gt;

&lt;p&gt;主存遵从冯诺依曼结构，同时存放数据和指令；一级缓存分别存放数据和指令，即IMem和DMem，这样就不会产生结构冒险的问题。&lt;/p&gt;

&lt;p&gt;对于寄存器堆来说，他也会产生结构冒险的问题，比如同时执行指令译码阶段（ID)的读和写回阶段（WB）写，而这可以利用寄存器的特性来避免。&lt;/p&gt;

&lt;p&gt;因为寄存器的周期比其他部件小，设为二分之一，那么只要使其在前二分之一的周期写，后二分之一的周期读，并设置独立的读写接口。&lt;/p&gt;

&lt;h2 id=&quot;数据冒险&quot;&gt;数据冒险&lt;/h2&gt;

&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-mipsasm&quot;&gt;sub $t0,$s1,$s2
add $s3,$t0,$s4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;add指令需要sub的完成以利用$t0&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;imgs/h1.png&quot; alt=&quot;数据冒险&quot; /&gt;
&lt;img src=&quot;imgs/h4.png&quot; alt=&quot;数据冒险&quot; /&gt;
&lt;img src=&quot;imgs/h5.png&quot; alt=&quot;数据冒险&quot; /&gt;
&lt;img src=&quot;imgs/h6.png&quot; alt=&quot;数据冒险&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Load-Use Hazard&lt;/p&gt;

&lt;p&gt;我们可以：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;让流水线停顿（stall），产生空泡（bubble）
    &lt;ul&gt;
      &lt;li&gt;即一条指令需要使用之前指令的运算结果，但是结果还没有写回&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;插入nop指令（软件层面解决问题）
    &lt;ul&gt;
      &lt;li&gt;缺点：与处理器结构相关，当前处理器的流水线是5级的，新处理器的流水线是8级的，这一调换就会产生错误。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据前递（Forwarding），又称旁路（Bypass），寄存器直通（register forwarding），转发机制&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;控制冒险&quot;&gt;控制冒险&lt;/h2&gt;

&lt;p&gt;在branch指令的第二条指令的取指阶段，由于并不知道上一条指令结束后是否发生分支（ALU产生的zero信号），就无法确定取指的地址，这就造成了控制冒险。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;imgs/h3.png&quot; alt=&quot;控制冒险&quot; /&gt;
&lt;img src=&quot;imgs/h7.png&quot; alt=&quot;控制冒险&quot; /&gt;
&lt;img src=&quot;imgs/h8.png&quot; alt=&quot;控制冒险&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直接转移&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;j Target
    &lt;ul&gt;
      &lt;li&gt;J型指令，前6位opcode,后26位address&lt;/li&gt;
      &lt;li&gt;New PC = {(PC + 4)[31..28], address, 00}&lt;/li&gt;
      &lt;li&gt;所需信息在取指阶段即可获得，流水线不停顿&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;beq rs, rt, imm16
    &lt;ul&gt;
      &lt;li&gt;I型指令，前6位opcode，5位rs，5位rt，16位立即数
        &lt;div class=&quot;language-vb highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rt&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;New&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SignExt&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imm16&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;New&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;执行阶段才能完成转移条件的判定（流水线停顿2周期）
        &lt;ul&gt;
          &lt;li&gt;为了判断rs和rt是否相等而使用了ALU&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在寄存器堆的输出端增加额外的比较电路（流水线停顿1周期）
        &lt;ul&gt;
          &lt;li&gt;由于判断寄存器相等比较简单，执行速度也非常快，所以可以做以上的硬件改动&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;间接转移&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;jr rs
    &lt;ul&gt;
      &lt;li&gt;R型指令，前6位opcode,5位rs，5位rt，5位rd，5位shamt，6位funct&lt;/li&gt;
      &lt;li&gt;New PC = R[rs]&lt;/li&gt;
      &lt;li&gt;译码阶段才能获得转移目标地址（流水线停顿1周期）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结以上控制冒险的影响&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;无条件直接转移： j Target
    &lt;ul&gt;
      &lt;li&gt;流水线无停顿&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;无条件间接转移： jr rs
    &lt;ul&gt;
      &lt;li&gt;流水线停顿1个周期&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;条件转移： beq rs,rt,imm16
    &lt;ul&gt;
      &lt;li&gt;流水线停顿1个周期&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;延迟转移技术&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;选择一条与条件转移指令无关的指令放到其后面，这样流水线就不用停顿，也不用废弃相关指令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;让流水线停顿（stall），产生空泡（bubble）
    &lt;ul&gt;
      &lt;li&gt;这次我们产生两个空泡，等到ALU产生zero信号&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;第七讲-存储层次结构todo&quot;&gt;第七讲 存储层次结构//TODO&lt;/h1&gt;
&lt;p&gt;存储器的特性&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;非易失性
    &lt;ul&gt;
      &lt;li&gt;易失性存储器：CPU（通用寄存器），主存&lt;/li&gt;
      &lt;li&gt;非易失性存储器：硬盘，BIOS芯片&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;可读可写
    &lt;ul&gt;
      &lt;li&gt;可读可写 主存和硬盘&lt;/li&gt;
      &lt;li&gt;只读 BIOS&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;随机访问
    &lt;ul&gt;
      &lt;li&gt;随机访问 主存和BIOS&lt;/li&gt;
      &lt;li&gt;不支持 硬盘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;访问时间&lt;/li&gt;
  &lt;li&gt;容量&lt;/li&gt;
  &lt;li&gt;价格&lt;/li&gt;
  &lt;li&gt;功耗&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算机启动顺序：CPU-&amp;gt;BISO-&amp;gt;硬盘-&amp;gt;内存&lt;/p&gt;

&lt;p&gt;内存交互：CPU &amp;lt;-&amp;gt; Cache(SRAM) &amp;lt;-&amp;gt; Memory(DRAM)&lt;/p&gt;

&lt;p&gt;DRAM和SRAM的比较
| | DRAM | SRAM |
| — | — | — |
| 存储单元 | 电容 | 双稳态触发器 |
| 集成度 | &lt;code class=&quot;highlighter-rouge&quot;&gt;高&lt;/code&gt; | 低 |
| 功耗 | &lt;code class=&quot;highlighter-rouge&quot;&gt;低&lt;/code&gt; | 高 |
| 价格 | &lt;code class=&quot;highlighter-rouge&quot;&gt;低&lt;/code&gt; | 高 |
| 速度 | 慢 | &lt;code class=&quot;highlighter-rouge&quot;&gt;快&lt;/code&gt; |
| 刷新 | 有 | &lt;code class=&quot;highlighter-rouge&quot;&gt;无&lt;/code&gt; |&lt;/p&gt;

&lt;h2 id=&quot;主存的工作原理&quot;&gt;主存的工作原理&lt;/h2&gt;
&lt;p&gt;DRAM芯片已一个存储阵列（Memory）为核心，这个阵列以行列的形式组织，行列的焦点就是一个存储单元，每个存储单元由一组唯一的行列地址指定，而储存单元通常由若干个比特构成，常见的有4bit和8bit。&lt;/p&gt;

&lt;p&gt;内存条通常由8个内存芯片焊接在一块电路板上构成一个内存模组（Memory Module），因此从外部给出了行地址和列地址之后，这些地址会同时送到每一个DRAM芯片，从而在每个内存芯片中选中对应的存储单元， 假如存储单元内含8bit，那可以同时向外传送64个bit&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BUS REQUEST
    &lt;ul&gt;
      &lt;li&gt;当CPU需要访问存储器时，首先申请系统总线&lt;/li&gt;
      &lt;li&gt;地址发往内存控制器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;[Precharge] and Row Access
    &lt;ul&gt;
      &lt;li&gt;内存控制器将地址分为行地址和列地址等多个部分，然后进行访存操作&lt;/li&gt;
      &lt;li&gt;预充电和行访问&lt;/li&gt;
      &lt;li&gt;通过存储总线发出的行地址会被行译码器（Row Decoder）所接收到，就会在存储阵列中选中对应的那一行，然后这一行所有的存储单元都会被放大（Sense Amplifiers）后放到缓冲区中。而这被称为激活（ACT(Activate)）或者行访问（RAS(Row Access Strobe)）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Column Access
    &lt;ul&gt;
      &lt;li&gt;通过存储总线发出的列地址会被列译码器（Column Decoder）所接收到&lt;/li&gt;
      &lt;li&gt;从缓冲区中选出对应的那个数，被选中的数就会送到IO接口上去。而这被称为READ或者列访问（CAS(Column Access Strobe)）&lt;/li&gt;
      &lt;li&gt;一般一次读一行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bus Transmission
    &lt;ul&gt;
      &lt;li&gt;内存控制器采样对应的数据,再送到CPU中去&lt;/li&gt;
      &lt;li&gt;若下次访问的是同一行，则直接列访问从缓冲区中取数据就可以&lt;/li&gt;
      &lt;li&gt;若不是这一行，就需要把激活的这一行关闭，这个过程称为预充电（Precharge，PRECH）&lt;/li&gt;
      &lt;li&gt;预充电可以有两种方式
        &lt;ul&gt;
          &lt;li&gt;再次访问时发现不在同一行，预充电&lt;/li&gt;
          &lt;li&gt;每次传出数据时都预充电&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;tRCD:Row to Column Delay&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从行选到列选的延迟时间&lt;/li&gt;
  &lt;li&gt;2-3个周期&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CL:CAS Latency&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从列选到数据输出的延迟周期&lt;/li&gt;
  &lt;li&gt;2-3个周期&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;tRP:RAS Precharge&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;行预充电（关闭行）&lt;/li&gt;
  &lt;li&gt;2-3个周期&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;为什么在最后一个数据送出之前发出预充电的命令？&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;imgs/h9.png&quot; alt=&quot;SDRAM&quot; /&gt;
&lt;img src=&quot;imgs/h10.png&quot; alt=&quot;SDRAM&quot; /&gt;
&lt;img src=&quot;imgs/h13.png&quot; alt=&quot;SDRAM&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;主存技术的发展&quot;&gt;主存技术的发展&lt;/h2&gt;
&lt;p&gt;内存的传输带宽&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;DDR3-1600&lt;/li&gt;
    &lt;li&gt;传输带宽12.8G/Hz&lt;/li&gt;
    &lt;li&gt;1600MHz * 64bit/8&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;SDR（单倍数据率）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每次访问存储阵列取出单倍的数据量&lt;/li&gt;
  &lt;li&gt;每个时钟的上升沿传输数据，接收端也用时钟的上升沿采样数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DDR（双倍数据率）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每次访问存储阵列取出两倍的数据量&lt;/li&gt;
  &lt;li&gt;在时钟的上升沿和下降沿都传输数据&lt;/li&gt;
  &lt;li&gt;这只是一种传输方式，应用到内存上就是DDR SDRAM，也可以用到其他领域&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;核心频率和等效频率之间的关系&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;访存延迟和访存带宽&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;DDR2（四倍数据率）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每次访问存储阵列取出四倍的数据量&lt;/li&gt;
  &lt;li&gt;在时钟的上升沿和下降沿都传I/O&lt;/li&gt;
  &lt;li&gt;I/O频率为两倍&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DDR3（八倍数据率）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每次访问存储阵列取出八倍的数据量&lt;/li&gt;
  &lt;li&gt;在时钟的上升沿和下降沿都传输数据&lt;/li&gt;
  &lt;li&gt;I/O频率为四倍&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过DDR技术，带宽得到了大幅提升，而延迟的进步却很有限&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1999年到2008年，行选时间（tRCD）延迟只降低了30%&lt;/li&gt;
  &lt;li&gt;而列选时间（CL）延迟也只降低了30%&lt;/li&gt;
  &lt;li&gt;存储器性能（DRAM）性能增长不到10倍&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是由SDRAM的基本单元结构决定的，也就是电容的充放电过程，如果不做材料的优化和改变，基于现在的SDRAM结构，想要优化和提升是很困难的&lt;/p&gt;

&lt;h2 id=&quot;高速缓存的工作原理&quot;&gt;高速缓存的工作原理&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;计算机程序从时间和空间都表现出“局部性”&lt;/li&gt;
  &lt;li&gt;时间局部性（Temporal Locality)
    &lt;ul&gt;
      &lt;li&gt;最近被访问的存储器单元很快还会被访问&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;空间局部性（Spatial Locality）
    &lt;ul&gt;
      &lt;li&gt;正在被访问的存储器单元附近的单元很快会被访问&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cache对空间局部性的利用&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从主存中取回待访问数据时，会同时取回与位置相邻的主存单元的数据&lt;/li&gt;
  &lt;li&gt;以数据块（Block）为单位和主存进行数据交换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cache对时间局部性的利用&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;保存近期频繁被访问的主存单元的数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经典例题&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;循环通常具有很好的时间局部性&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;循环通常具有很好的空间局部性&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;数组通常具有很好的空间局部性&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cache的访问过程：Cache命中（Cache Hit），Cache失效（Cache Miss）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;imgs/h11.png&quot; alt=&quot;SDRAM&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache取数据块时读内存的地址是16字节对齐&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;imgs/h12.png&quot; alt=&quot;Cache&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Cache的写策略：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;“Cache命中”时的写策略
    &lt;ol&gt;
      &lt;li&gt;写穿透（Write Through）：数据同时写入Cache和主存&lt;/li&gt;
      &lt;li&gt;写返回（Write Back）：数据只写入Cache，仅当该数据块被替换时才将数据写回主存&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;“Cache失效”时的写策略
    &lt;ol&gt;
      &lt;li&gt;写不分配（Write Non-Allocate）：直接将数据写入主存&lt;/li&gt;
      &lt;li&gt;写分配（Write Allocate）：将该数据所在的块读入Cache后，再将数据写入Cache&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;高速缓存的设计要点&quot;&gt;高速缓存的设计要点&lt;/h2&gt;
&lt;p&gt;命中率（Hit Rate）和失效率（Miss Rate）&lt;/p&gt;

&lt;p&gt;命中时间（Hit Time）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从Cache将命中数据返回的时间&lt;/li&gt;
  &lt;li&gt;L1 Cache约1-3个周期&lt;/li&gt;
  &lt;li&gt;L2 Cache约5-20个周期&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;失效代价（Miss Penalty）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从主存读取数据并返回的时间&lt;/li&gt;
  &lt;li&gt;约100-300个周期&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;平均访存时间Average Memory Access Time = Hit Time + Miss Penalty * Miss Rate&lt;/p&gt;

&lt;p&gt;Cache失效的原因&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;义务失效（Compulsory Miss） 第一次访问数据块时，也称冷启失效（Cold Start Miss）&lt;/li&gt;
  &lt;li&gt;容量失效（Capacity Miss） Cache无法保存程序访问时所需的所有数据块&lt;/li&gt;
  &lt;li&gt;冲突失效（Conflict Miss） 多个存储器位置映射到同一Cache位置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cache的映射策略&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;解决冲突失效&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;直接映射Cache&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;二路组相连Cache&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;四路组相连Cache&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;常见的Cache替换算法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;随机（Random)
    &lt;ul&gt;
      &lt;li&gt;硬件随机选择一个Cache块替换&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;轮换（Round-Robin）
    &lt;ul&gt;
      &lt;li&gt;按照预先设定的顺序依次选择Cache块替换&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;最近最少使用（LRU）
    &lt;ul&gt;
      &lt;li&gt;硬件记录访问历史信息&lt;/li&gt;
      &lt;li&gt;选择距离现在最长时间未被访问的Cache块替换&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;分为数据和指令Cache的原因在于解决这两者局部性冲突&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;存储容量的计算&quot;&gt;存储容量的计算&lt;/h3&gt;
&lt;p&gt;K:2^10, M:2^20, G:2^30, T:2^40&lt;/p&gt;

&lt;p&gt;MB和MiB&lt;/p&gt;

&lt;h1 id=&quot;第八讲-中断和异常todo&quot;&gt;第八讲 中断和异常//TODO&lt;/h1&gt;

&lt;p&gt;第一个带有异常处理的系统：UNIVAC，1951年&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;算术运算溢出时：转向地址0执行&lt;code class=&quot;highlighter-rouge&quot;&gt;两条修复指令&lt;/code&gt;，或者停机&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个带有外部中断的系统：DYSEAC，1954年&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;有两个程序计数器（PC），根据I/O信号进行切换&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;在程序运行时，系统外部、内部或现行程序本身出现需要特殊处理的“事件”&lt;/li&gt;
  &lt;li&gt;CPU立即强行中止现行程序的运行，改变机器的工作状态并启动相应的程序来处理这些“事件”&lt;/li&gt;
  &lt;li&gt;处理完成后，CPU恢复原来的程序运行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;8086的主要特点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;对外有16根数据线
    &lt;ul&gt;
      &lt;li&gt;内部有四个16位通用寄存器，既能处理16位数据，也能处理8位数据&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对外有20根地址线，可寻址的内存空间为1MB&lt;/li&gt;
  &lt;li&gt;物理地址的形成采用“段加偏移”的方式&lt;/li&gt;
  &lt;li&gt;存储器中保留两个专用区域
    &lt;ul&gt;
      &lt;li&gt;中断向量表区：00000H~003FFH（地址最低的1KB）
        &lt;ul&gt;
          &lt;li&gt;存放256个中断向量(中断服务程序的入口地址)，每个占4个字节单元&lt;/li&gt;
          &lt;li&gt;每个中断类型对应一个中断向量（4字节）&lt;/li&gt;
          &lt;li&gt;前两个字节存放入口地址的&lt;code class=&quot;highlighter-rouge&quot;&gt;偏移量（IP）&lt;/code&gt;，后两个字节存放入口地址的&lt;code class=&quot;highlighter-rouge&quot;&gt;段基值（CS）&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;CS左移4位 + IP = 物理地址&lt;/li&gt;
          &lt;li&gt;CS和IP类似于PC寄存器&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;初始化程序区：FFFF0H~FFFFFH（地址最高的16B）
 &lt;img src=&quot;imgs/h14.png&quot; alt=&quot;存储器&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;指令的寻址&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;实模式 CS:IP&lt;/li&gt;
  &lt;li&gt;保护模式 CS:EIP
    &lt;ul&gt;
      &lt;li&gt;保护模式下，段基址不在CS中，而是在内存中
  &lt;img src=&quot;imgs/h15.png&quot; alt=&quot;存储器&quot; /&gt;
  &lt;img src=&quot;imgs/h16.png&quot; alt=&quot;存储器&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;中断的处理过程&quot;&gt;中断的处理过程&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;关中断
    &lt;ul&gt;
      &lt;li&gt;CPU关闭中断响应，即不再接收其他外部中断请求&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;保存断点
    &lt;ul&gt;
      &lt;li&gt;将发生中断处的指令地址压入堆栈，以使中断处理完后能正确地返回&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;识别中断源
    &lt;ul&gt;
      &lt;li&gt;CPU识别中断的来源，确定中断类型型号，从而找到相应的中断服务程序的入口地址&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;保护现场
    &lt;ul&gt;
      &lt;li&gt;将发生中断处的有关寄存器（中断服务程序中要使用的寄存器）以及标志寄存器的内容压入堆栈&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;执行中断的服务程序
    &lt;ul&gt;
      &lt;li&gt;转到中断服务程序入口开始执行，可在适当时刻重新开放中断，以便允许响应较高优先级的外部中断
        &lt;ul&gt;
          &lt;li&gt;设置标志寄存器（FLAGS）中的中断标志IF，1为允许CPU响应&lt;code class=&quot;highlighter-rouge&quot;&gt;可屏蔽中断请求&lt;/code&gt;，0为不允许
            &lt;ul&gt;
              &lt;li&gt;STI设置IF为1&lt;/li&gt;
              &lt;li&gt;CLI设置IF为0&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;恢复现场，返回主程序继续运行
    &lt;ul&gt;
      &lt;li&gt;把”保护现场“时压入堆栈的信息弹回原寄存器，然后执行中断返回指令，从而返回主程序继续运行
        &lt;ul&gt;
          &lt;li&gt;IRET指令（中断返回）&lt;/li&gt;
          &lt;li&gt;从栈顶弹出3个字分别放入IP、CS和FLAGS寄存器&lt;/li&gt;
          &lt;li&gt;扩展：IRETD指令，IRETQ指令&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;imgs/h17.png&quot; alt=&quot;存储器&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;内部中断的分类说明&quot;&gt;内部中断的分类说明&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;除法错中断&lt;/code&gt;也被称为&lt;code class=&quot;highlighter-rouge&quot;&gt;除0中断&lt;/code&gt;（类型0）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在执行除法指令后，若所得的商超出了目标寄存器所能表示的范围，比如用数值0作除数，则CPU立即产生一个类型0中断&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;溢出中断&lt;/code&gt;（类型4）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;执行INTO指令时，若溢出标志为OF为1，则将引起类型为4的内部中断&lt;/li&gt;
  &lt;li&gt;执行INTO指令时，若溢出标志为OF为0，则INTO指令执行空操作&lt;/li&gt;
  &lt;li&gt;INTO指令通常安排在算术运算指令之后，以便在发生溢出时能及时处理&lt;/li&gt;
  &lt;li&gt;INTO指令等同于指令INT 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;ADD AX, BX
INTO
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;单步中断&lt;/code&gt;（类型1）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当标志寄存器的TF（跟踪标志）置为1之后，CPU便处于单步工作方式&lt;/li&gt;
  &lt;li&gt;在单步工作方式下，CPU每执行完一条指令，就会自动产生一个类型1中断，进入类型1中断服务程序&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;断点中断&lt;/code&gt;（类型3）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在所有INT n形式的指令中，只有断点中断指令INT 3是一条单字节长的指令，其他都是两字节指令&lt;/li&gt;
  &lt;li&gt;因为在实际调试中，INT 3指令会代替要调试的指令，一个指令的最小长度为一个字节，而为了避免代替过之后剩余的指令产生偏移，必须设置成最小长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;内部中断的特点&quot;&gt;内部中断的特点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;中断类型号
    &lt;ul&gt;
      &lt;li&gt;内部中断的类型号由CPU内部产生&lt;/li&gt;
      &lt;li&gt;外部中断则需要从外设读取中断类型号&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;屏蔽方式
    &lt;ul&gt;
      &lt;li&gt;除单步中断外，所有内部中断都不可以用软件方法来禁止（屏蔽）&lt;/li&gt;
      &lt;li&gt;单步中断可通过软件将TF标志置1或清0来允许或禁止&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;优先级
    &lt;ul&gt;
      &lt;li&gt;除单步中断外，所有内部中断的优先级都比外部中断高&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;基于中断的功能调用&quot;&gt;基于中断的功能调用&lt;/h2&gt;

&lt;p&gt;INT n指令说明&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;x86系统提供的直接调用中断服务程序的手段&lt;/li&gt;
  &lt;li&gt;n为0~255中的某一个数，对应中断类型码&lt;/li&gt;
  &lt;li&gt;操作
    &lt;ol&gt;
      &lt;li&gt;将FLAGS寄存器的内容压栈&lt;/li&gt;
      &lt;li&gt;清除中断标志IF和单步标志TF&lt;/li&gt;
      &lt;li&gt;将CS和IF寄存器的内容压栈&lt;/li&gt;
      &lt;li&gt;根据中断类型码查找中断向量表，取得对应中断服务程序的入口地址&lt;/li&gt;
      &lt;li&gt;将入口地址分别装入CS和IP寄存器&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;溢出中断&lt;/li&gt;
  &lt;li&gt;BIOS中断
    &lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt; MOV AH,1    ;设置功能号，对于1AH号中断，AH=1为”置时钟“
 MOV CX,0    ;设置入口参数，CH:CL=时：分
 MOV DX,0    ;设置入口参数，DH:DL=秒：1/100分
 INT 1AH     ;调用1AH号中断
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;DOS中断
    &lt;ul&gt;
      &lt;li&gt;包含常用的功能程序，分别实现文件管理、存储管理、作业管理和设备管理等功能&lt;/li&gt;
      &lt;li&gt;共用21H号中断入口，通过传参数的方式设置功能号，以选择执行不同功能模块的代码&lt;/li&gt;
      &lt;li&gt;说明
        &lt;ul&gt;
          &lt;li&gt;DOS中断功能比BIOS中断更齐全、完整&lt;/li&gt;
          &lt;li&gt;进一步屏蔽了设备的物理特性及其接口特性
            &lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt; MOV AH,6    ;设置功能号，DOS中断6号功能为屏幕输入输出
 MOV DL,'$'  ;设置入口参数，DL中放置待输出的字符
 INT 21H     ;调用DOS中断
&lt;/code&gt;&lt;/pre&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;第九讲-输入输出设备&quot;&gt;第九讲 输入输出设备&lt;/h1&gt;

&lt;h2 id=&quot;输入输出接口的基本功能&quot;&gt;输入输出接口的基本功能&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;数据缓冲
    &lt;ul&gt;
      &lt;li&gt;解决CPU和外设之间的速度差距&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;提供联络信息
    &lt;ul&gt;
      &lt;li&gt;协调与同步数据交换过程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;信号与模拟信号格式的转换
    &lt;ul&gt;
      &lt;li&gt;模/数、数/模转换、串/并、并/串转换，电平转换&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;设备选择&lt;/li&gt;
  &lt;li&gt;中断管理&lt;/li&gt;
  &lt;li&gt;可编程功能&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显卡、南桥芯片、并行接口电路&lt;/p&gt;

&lt;h2 id=&quot;输入输出接口的编址方式&quot;&gt;输入输出接口的编址方式&lt;/h2&gt;
&lt;p&gt;I/O端口&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;I/O接口内部包含一组称为&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O端口&lt;/code&gt;的寄存器&lt;/li&gt;
  &lt;li&gt;每个I/O端口都需有自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;端口地址&lt;/code&gt;（或称端口号），以便CPU访问&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;常见的I/O端口编址方式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;I/O端口和存储器分开编址
    &lt;ul&gt;
      &lt;li&gt;I/O Mapped I/O&lt;/li&gt;
      &lt;li&gt;x86&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;I/O端口和存储器统一编址
    &lt;ul&gt;
      &lt;li&gt;Memory Mapped I/O&lt;/li&gt;
      &lt;li&gt;ARM，MIPS，POWER PC&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I/O端口和存储器分开编址(x86指令)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;IN指令（输入）
    &lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;IN AC,PORT
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;OUT指令（输出）
    &lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;OUT PORT,AC
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;端口地址为0~255
    &lt;ul&gt;
      &lt;li&gt;直接寻址，间接寻址（DX保存端口地址）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;端口地址大于255
    &lt;ul&gt;
      &lt;li&gt;间接寻址（DX保存端口地址）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;M/IO信号&lt;/code&gt;去指定存储器寻址还是I/O接口寻址（=0）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I/O端口和存储器统一编址&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;优点
    &lt;ul&gt;
      &lt;li&gt;可以利用为存储器开发的丰富的指令&lt;/li&gt;
      &lt;li&gt;简化内部结构，减少CPU引脚&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缺点
    &lt;ul&gt;
      &lt;li&gt;存储地址空间减小&lt;/li&gt;
      &lt;li&gt;指令执行时间长&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I/O端口和存储器分开编址&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;优缺点与统一编址相对&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;输入输出的控制方式&quot;&gt;输入输出的控制方式&lt;/h2&gt;

&lt;p&gt;I/O控制方式的含义：CPU如何控制外设的数据传送&lt;/p&gt;

&lt;p&gt;I/O控制方式的分类&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;程序控制方式
    &lt;ol&gt;
      &lt;li&gt;无条件传送方式
        &lt;ul&gt;
          &lt;li&gt;简单外设&lt;/li&gt;
          &lt;li&gt;优点：控制程序简单；缺点：只适用于简单外设&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;程序查询传送方式
        &lt;ul&gt;
          &lt;li&gt;CPU通过执行一段程序，不断查询外设的工作状态&lt;/li&gt;
          &lt;li&gt;在确定外设已经准备就绪时，才进行数据传送&lt;/li&gt;
          &lt;li&gt;控制寄存器-&amp;gt;IO缓冲寄存器和状态寄存器&lt;/li&gt;
          &lt;li&gt;优点：更准确和可靠；缺点：查询外设状态占用了大量的时间&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;共同的优缺点
        &lt;ul&gt;
          &lt;li&gt;优点：对外设要求低，操作流程清晰&lt;/li&gt;
          &lt;li&gt;缺点：由CPU进行数据传送操作，占用了宝贵的运算资源&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;中断控制方式&lt;/li&gt;
  &lt;li&gt;直接存储器访问（DMA）方式&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;中断控制方式&quot;&gt;中断控制方式&lt;/h2&gt;

&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CPU可以和外设并行工作，提高了工作效率&lt;/li&gt;
  &lt;li&gt;外围设备具有申请服务的主动权&lt;/li&gt;
  &lt;li&gt;一定程度上满足了I/O处理的实时性要求&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;外设和存储器之间的数据交换仍由CPU承担
    &lt;ul&gt;
      &lt;li&gt;使用数据传送指令，占用了宝贵的CPU运算资源&lt;/li&gt;
      &lt;li&gt;数据要经过CPU中的通用寄存器中转，过程冗长&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;进入和退出中断服务程序，需要额外的指令&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;外部中断的处理过程&quot;&gt;外部中断的处理过程&lt;/h2&gt;

&lt;p&gt;外部中断，也称硬件终端&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;由CPU外部的中断请求信号启动的中断&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;x86 CPU为外部中断提供两个引脚&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;NMI：非屏蔽中断
    &lt;ul&gt;
      &lt;li&gt;信号非常重要，不希望被屏蔽&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;INTR：可屏蔽中断
    &lt;ul&gt;
      &lt;li&gt;中断控制器连接多个外设
        &lt;ul&gt;
          &lt;li&gt;可编程中断控制器：PIC&lt;/li&gt;
          &lt;li&gt;高级可编程中断控制器：APIC&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可屏蔽中断的处理过程&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;外设发中断请求信号&lt;/li&gt;
  &lt;li&gt;CPU完成现行指令，发出中断响应信号&lt;/li&gt;
  &lt;li&gt;CPU读取中断类型码&lt;/li&gt;
  &lt;li&gt;当前CS/IP/PSW压栈&lt;/li&gt;
  &lt;li&gt;清除IF和TF&lt;/li&gt;
  &lt;li&gt;取CS/IP新值&lt;/li&gt;
  &lt;li&gt;转入中断服务程序&lt;/li&gt;
  &lt;li&gt;开放中断（可选）&lt;/li&gt;
  &lt;li&gt;IRET指令使旧的CS/IP/PSW弹出堆栈&lt;/li&gt;
  &lt;li&gt;返回被中断的程序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;中断嵌套&lt;/p&gt;

&lt;h2 id=&quot;直接存储器访问方式dma&quot;&gt;直接存储器访问方式（DMA）&lt;/h2&gt;

&lt;p&gt;DMA&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数据传送过程不需要CPU干预（不需要执行程序指令）&lt;/li&gt;
  &lt;li&gt;由专门硬件控制电路控制，进行外设与存储器间直接数据传送&lt;/li&gt;
  &lt;li&gt;该专门硬件控制电路称为DMA控制器，简称DMAC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DMAC的基本工作步骤&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;CPU设置DMAC内部配置寄存器&lt;/li&gt;
  &lt;li&gt;DMAC处于空闲等待状态&lt;/li&gt;
  &lt;li&gt;I/O接口向DMAC发出DMA传送申请&lt;/li&gt;
  &lt;li&gt;DMAC响应I/O接口的申请&lt;/li&gt;
  &lt;li&gt;DMAC向I/O接口发起总线读传输&lt;/li&gt;
  &lt;li&gt;DMAC向存储器发起总线写传输&lt;/li&gt;
  &lt;li&gt;重复5~6直到本次DMA传送完成&lt;/li&gt;
  &lt;li&gt;返回2，等待下一次DMA传送申请&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;DMAC的主要配置参数&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CPU设置DMAC内部配置寄存器，一般包括
    &lt;ol&gt;
      &lt;li&gt;源地址的初始值以及传送时地址增减方式&lt;/li&gt;
      &lt;li&gt;目的地址的初始值以及传送时地址增减方式&lt;/li&gt;
      &lt;li&gt;待传送数据的长度&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;阿塔纳索夫-贝瑞计算机（Atanasoff-Berry Computer，简称ABC）是法定的世界上第一台电子计算机，是爱荷华州立大学的约翰·文森特·阿塔纳索夫（John Vincent Atanasoff）和他的研究生克利福特·贝瑞（Clifford Berry）在1937年设计，不可编程，仅仅设计用于求解线性方程组，并在1942年成功进行了测试。&lt;/p&gt;

&lt;p&gt;ENIAC是第二台计算机和第一台通用计算机。&lt;/p&gt;</content><author><name></name></author><summary type="html">MOS（金属氧化物半导体 Metal-Oxide-Semiconductor）</summary></entry></feed>